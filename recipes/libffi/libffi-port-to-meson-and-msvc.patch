From 697e809e646f59b6c1a70231e74553dd1ce18b72 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Mon, 28 Mar 2016 20:34:48 +0530
Subject: [PATCH 01/11] Port to the Meson build system

Also fixes some inconsistency between usage of #ifdef and #if inside C macros
Include support for universal builds and multilib builds via suffixed
arch-specific headers in ${prefix}/include + various other fixes.
---
 fficonfig.h.meson          | 161 +++++++++++++++++++++++++++++++
 include/ffi_common.h       |   6 +-
 include/ffi_noarch.h.meson |  21 ++++
 include/meson.build        |  29 ++++++
 libffi.pc.in               |   4 +-
 meson.build                | 218 +++++++++++++++++++++++++++++++++++++++++
 meson_options.txt          |  11 +++
 src/meson.build            | 234 +++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 678 insertions(+), 6 deletions(-)
 create mode 100644 fficonfig.h.meson
 create mode 100644 include/ffi_noarch.h.meson
 create mode 100644 include/meson.build
 create mode 100644 meson.build
 create mode 100644 meson_options.txt
 create mode 100644 src/meson.build

diff --git a/fficonfig.h.meson b/fficonfig.h.meson
new file mode 100644
index 0000000..a882290
--- /dev/null
+++ b/fficonfig.h.meson
@@ -0,0 +1,161 @@
+/* fficonfig.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#mesondefine AC_APPLE_UNIVERSAL_BUILD
+
+/* Define to the flags needed for the .section .eh_frame directive. */
+#mesondefine EH_FRAME_FLAGS
+
+/* Define this if you want extra debugging. */
+#mesondefine FFI_DEBUG
+
+/* Cannot use PROT_EXEC on this target, so, we revert to alternative means */
+#mesondefine FFI_EXEC_TRAMPOLINE_TABLE
+
+/* Define this if you want to enable pax emulated trampolines */
+#mesondefine FFI_MMAP_EXEC_EMUTRAMP_PAX
+
+/* Cannot use malloc on this target, so, we revert to alternative means */
+#mesondefine FFI_MMAP_EXEC_WRIT
+
+/* Define this if you do not want support for the raw API. */
+#mesondefine FFI_NO_RAW_API
+
+/* Define this if you do not want support for aggregate types. */
+#mesondefine FFI_NO_STRUCTS
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#mesondefine HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used */
+#mesondefine HAVE_ALLOCA_H
+
+/* Define if your assembler supports .ascii. */
+#mesondefine HAVE_AS_ASCII_PSEUDO_OP
+
+/* Define if your assembler supports .cfi_* directives. */
+#mesondefine HAVE_AS_CFI_PSEUDO_OP
+
+/* Define if your assembler supports .register. */
+#mesondefine HAVE_AS_REGISTER_PSEUDO_OP
+
+/* Define if your assembler and linker support unaligned PC relative relocs.
+   */
+#mesondefine HAVE_AS_SPARC_UA_PCREL
+
+/* Define if your assembler supports .string. */
+#mesondefine HAVE_AS_STRING_PSEUDO_OP
+
+/* Define if your assembler supports unwind section type. */
+#mesondefine HAVE_AS_X86_64_UNWIND_SECTION_TYPE
+
+/* Define if your assembler supports PC relative relocs. */
+#mesondefine HAVE_AS_X86_PCREL
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#mesondefine HAVE_DLFCN_H
+
+/* Define if __attribute__((visibility("hidden"))) is supported. */
+#mesondefine HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#mesondefine HAVE_INTTYPES_H
+
+/* Define if you have the long double type and it is bigger than a double */
+#mesondefine HAVE_LONG_DOUBLE
+
+/* Define if you support more than one size of the long double type */
+#mesondefine HAVE_LONG_DOUBLE_VARIANT
+
+/* Define to 1 if you have the `memcpy' function. */
+#mesondefine HAVE_MEMCPY
+
+/* Define to 1 if you have the <memory.h> header file. */
+#mesondefine HAVE_MEMORY_H
+
+/* Define to 1 if you have the `mkostemp' function. */
+#mesondefine HAVE_MKOSTEMP
+
+/* Define to 1 if you have the `mmap' function. */
+#mesondefine HAVE_MMAP
+
+/* Define if mmap with MAP_ANON(YMOUS) works. */
+#mesondefine HAVE_MMAP_ANON
+
+/* Define if mmap of /dev/zero works. */
+#mesondefine HAVE_MMAP_DEV_ZERO
+
+/* Define if read-only mmap of a plain file works. */
+#mesondefine HAVE_MMAP_FILE
+
+/* Define if .eh_frame sections should be read-only. */
+#mesondefine HAVE_RO_EH_FRAME
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#mesondefine HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#mesondefine HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#mesondefine HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#mesondefine HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#mesondefine HAVE_SYS_MMAN_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#mesondefine HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#mesondefine HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#mesondefine HAVE_UNISTD_H
+
+/* The size of `double', as computed by sizeof. */
+#mesondefine SIZEOF_DOUBLE
+
+/* The size of `long double', as computed by sizeof. */
+#mesondefine SIZEOF_LONG_DOUBLE
+
+/* The size of `size_t', as computed by sizeof. */
+#mesondefine SIZEOF_SIZE_T
+
+/* Define if symbols are underscored. */
+#mesondefine SYMBOL_UNDERSCORE
+
+/* Define this if you are using Purify and want to suppress spurious messages.
+   */
+#mesondefine USING_PURIFY
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+#if defined __BIG_ENDIAN__
+#define WORDS_BIGENDIAN 1
+#endif
+#else
+#ifndef WORDS_BIGENDIAN
+#mesondefine WORDS_BIGENDIAN
+#endif
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#mesondefine size_t
+
+#ifdef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE
+#ifdef LIBFFI_ASM
+#define FFI_HIDDEN(name) .hidden name
+#else
+#define FFI_HIDDEN __attribute__ ((visibility ("hidden")))
+#endif
+#else
+#ifdef LIBFFI_ASM
+#define FFI_HIDDEN(name)
+#else
+#define FFI_HIDDEN
+#endif
+#endif
diff --git a/include/ffi_common.h b/include/ffi_common.h
index 7fb0a64..79d71f6 100644
--- a/include/ffi_common.h
+++ b/include/ffi_common.h
@@ -48,12 +48,10 @@ char *alloca ();
 #endif
 
 /* Check for the existence of memcpy. */
-#if STDC_HEADERS
+#if HAVE_MEMCPY
 # include <string.h>
 #else
-# ifndef HAVE_MEMCPY
-#  define memcpy(d, s, n) bcopy ((s), (d), (n))
-# endif
+# define memcpy(d, s, n) bcopy ((s), (d), (n))
 #endif
 
 #if defined(FFI_DEBUG)
diff --git a/include/ffi_noarch.h.meson b/include/ffi_noarch.h.meson
new file mode 100644
index 0000000..9994c8d
--- /dev/null
+++ b/include/ffi_noarch.h.meson
@@ -0,0 +1,21 @@
+/* Include the correct @HEADER@.h automatically. This helps us create prefixes
+ * with multi-lib Linux and OSX/iOS universal builds. To avoid listing all
+ * possible architectures here, we try the configured target arch first and then
+ * include the most common multilib/universal setups in the #elif ladder */
+#ifdef __@ARCH@__
+#include "@HEADER@-@ARCH@.h"
+#elif defined(__i386__) || defined(_M_IX86)
+#include "@HEADER@-x86.h"
+#elif defined(__x86_64__) || defined(_M_X64)
+#include "@HEADER@-x86_64.h"
+#elif defined(__arm__) || defined(_M_ARM)
+#include "@HEADER@-arm.h"
+#elif defined(__aarch64__)
+#include "@HEADER@-aarch64.h"
+#elif defined(__powerpc__) || defined(_M_PPC)
+#include "@HEADER@-powerpc.h"
+#elif defined(__powerpc64__)
+#include "@HEADER@-powerpc64.h"
+#else
+#error "Unsupported Architecture"
+#endif
diff --git a/include/meson.build b/include/meson.build
new file mode 100644
index 0000000..7887bf0
--- /dev/null
+++ b/include/meson.build
@@ -0,0 +1,29 @@
+# Install arch-specific ffi.h file as ffi-$ARCH.h
+configure_file(input : 'ffi.h.in',
+  output : 'ffi-@0@.h'.format(host_cpu_family),
+  configuration : ffi_conf,
+  install_dir : 'include')
+
+# Install arch-specific ffitarget.h as ffitarget-$ARCH.h
+# XXX: Hack to install the header with a different name
+configure_file(
+  input : '../src/@0@/ffitarget.h'.format(arch_subdir),
+  output : 'ffitarget-@0@.h'.format(host_cpu_family),
+  configuration : configuration_data(),
+  install_dir : 'include')
+
+# Install noarch ffi.h that includes the arch-specific ffi.h header
+ffitarget_h_noarch_conf = configuration_data()
+ffitarget_h_noarch_conf.set('ARCH', host_cpu_family)
+ffitarget_h_noarch_conf.set('HEADER', 'ffitarget')
+configure_file(input : 'ffi_noarch.h.meson', output : 'ffitarget.h',
+  configuration : ffitarget_h_noarch_conf,
+  install_dir : 'include')
+
+# Install noarch ffitarget.h that includes the arch-specific fftarget.h
+ffi_h_noarch_conf = configuration_data()
+ffi_h_noarch_conf.set('ARCH', host_cpu_family)
+ffi_h_noarch_conf.set('HEADER', 'ffi')
+configure_file(input : 'ffi_noarch.h.meson', output : 'ffi.h',
+  configuration : ffi_h_noarch_conf,
+  install_dir : 'include')
diff --git a/libffi.pc.in b/libffi.pc.in
index 6fad83b..c511efe 100644
--- a/libffi.pc.in
+++ b/libffi.pc.in
@@ -4,8 +4,8 @@ libdir=@libdir@
 toolexeclibdir=@toolexeclibdir@
 includedir=@includedir@
 
-Name: @PACKAGE_NAME@
+Name: libffi
 Description: Library supporting Foreign Function Interfaces
 Version: @PACKAGE_VERSION@
-Libs: -L${toolexeclibdir} -lffi
+Libs: -L${libdir} -lffi
 Cflags: -I${includedir}
diff --git a/meson.build b/meson.build
new file mode 100644
index 0000000..d5bb2e8
--- /dev/null
+++ b/meson.build
@@ -0,0 +1,218 @@
+project('libffi', 'c', version : '3.2.1',
+        meson_version : '>= 0.37.1',
+        default_options : ['buildtype=debugoptimized',
+                           'warning_level=1'])
+
+cc = meson.get_compiler('c')
+
+ffi_conf = configuration_data()
+
+# NOTE: host = "cross" or "target"
+host_cpu_family = host_machine.cpu_family()
+host_system = host_machine.system()
+message('host cpu: ' + host_machine.cpu())
+message('host cpu_family: ' + host_cpu_family)
+message('host system: ' + host_system)
+
+# IMPORTANT: Some of these use set(), others set10(), and others only set(, 1)
+# conditionally. This is on purpose.
+# Some C code uses #ifdef HAVE_XXX and some #if !HAVE_XXX. To make things worse,
+# some symbols are also used inside .h.in headers that are configured and then
+# #include-ed at build time and installed. Each symbol has been carefully
+# checked. Please double-check before changing.
+#
+# Nothing checks for STACK_DIRECTION
+
+if cc.symbols_have_underscore_prefix()
+  ffi_conf.set('SYMBOL_UNDERSCORE', 1)
+endif
+
+# Assembly directive support
+if cc.compiles('asm (".cfi_startproc\n.cfi_endproc");', name : 'ASM .cfi')
+  ffi_conf.set('HAVE_AS_CFI_PSEUDO_OP', 1)
+endif
+
+if host_cpu_family == 'sparc'
+  if cc.compiles('asm (".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text");', name : 'ASM SPARC UA PCREL')
+    ffi_conf.set('HAVE_AS_SPARC_UA_PCREL', 1)
+  endif
+  if cc.compiles('asm (".register %g2, #scratch");', name : 'ASM .register')
+    ffi_conf.set('HAVE_AS_REGISTER_PSEUDO_OP', 1)
+  endif
+endif
+
+if host_cpu_family == 'x86' or host_cpu_family == 'x86_64'
+  if cc.compiles('asm (".text; foo: nop; .data; .long foo-.; .text");', name : 'ASM x86 PCREL')
+    ffi_conf.set('HAVE_AS_X86_PCREL', 1)
+  endif
+  if cc.compiles('asm (".ascii \\"string\\"");', name : 'ASM .ascii')
+    ffi_conf.set('HAVE_AS_ASCII_PSEUDO_OP', 1)
+  endif
+  if cc.compiles('asm (".string \\"string\\"");', name : 'ASM .string')
+    ffi_conf.set('HAVE_AS_STRING_PSEUDO_OP', 1)
+  endif
+endif
+
+# If not defined, define it as unsigned int
+size_t = cc.sizeof('size_t')
+if size_t > 0
+  ffi_conf.set('SIZEOF_SIZE_T', size_t)
+else
+  message('"size_t" is not defined, using fallback')
+  ffi_conf.set('size_t', 'unsigned int')
+endif
+
+# Checking for long double is important
+size_long_double = cc.sizeof('long double')
+size_double = cc.sizeof('double')
+ffi_conf.set('SIZEOF_LONG_DOUBLE', size_long_double)
+ffi_conf.set('SIZEOF_DOUBLE', size_double)
+ffi_conf.set('HAVE_LONG_DOUBLE', 0)
+ffi_conf.set('HAVE_LONG_DOUBLE_VARIANT', 0)
+if host_cpu_family == 'alpha'
+  message('"long double" support is detected at compile-time')
+  ffi_conf.set('HAVE_LONG_DOUBLE', 'defined(__LONG_DOUBLE_128__)')
+elif host_cpu_family == 'mips'
+  message('"long double" support is detected at compile-time')
+  ffi_conf.set('HAVE_LONG_DOUBLE', 'defined(__mips64)')
+else
+  if size_long_double > 0
+    if size_long_double > size_double
+      message('sizeof "long double" is greater than "double"')
+      ffi_conf.set('HAVE_LONG_DOUBLE', 1)
+      if host_cpu_family == 'powerpc' and host_system != 'darwin'
+	message('"long double" size can be different')
+	ffi_conf.set('HAVE_LONG_DOUBLE_VARIANT', 1)
+      endif
+    endif
+  endif
+endif
+
+# Exception handling frame
+if cc.get_id() == 'gcc' or cc.get_id() == 'llvm'
+  # FIXME: Actually check for this instead of hard-coding it
+  # Also, check if this is actually correct
+  if host_cpu_family == 'x86_64'
+    message('.eh_frame is hard-coded to not be ro')
+    ffi_conf.set('EH_FRAME_FLAGS', '"aw"')
+  else
+    message('.eh_frame is hard-coded to ro')
+    ffi_conf.set('HAVE_RO_EH_FRAME', 1)
+    ffi_conf.set('EH_FRAME_FLAGS', '"a"')
+  endif
+endif
+
+if host_cpu_family == 'arm' and host_system == 'darwin'
+  message('Cannot use PROT_EXEC on this target, using fallback')
+  ffi_conf.set('FFI_EXEC_TRAMPOLINE_TABLE', 1)
+else
+  ffi_conf.set('FFI_EXEC_TRAMPOLINE_TABLE', 0)
+endif
+
+if host_system == 'darwin' or host_system == 'openbsd' or host_system == 'freebsd' or host_system == 'solaris'
+  message('Cannot use malloc on this target, using fallback')
+  ffi_conf.set('FFI_MMAP_EXEC_WRIT', 1)
+endif
+
+if host_cpu_family == 'x86_64' and cc.get_id() != 'msvc'
+  # FIXME: Actually check for this instead of hard-coding it
+  message('Assembler supports .unwind section type')
+  ffi_conf.set('HAVE_AS_X86_64_UNWIND_SECTION_TYPE', 1)
+endif
+
+# Check mmap()
+if cc.has_function('mmap')
+  ffi_conf.set('HAVE_MMAP', 1)
+endif
+ffi_conf.set('HAVE_MMAP_FILE', 1) # Works everywhere
+ffi_conf.set('HAVE_MMAP_DEV_ZERO',
+  host_system != 'windows' and host_system != 'darwin')
+mmap_anon = '''#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+int n = MAP_ANONYMOUS;
+'''
+ffi_conf.set('HAVE_MMAP_ANON',
+  cc.compiles(mmap_anon, name : 'mmap anonymous'))
+
+# Misc functions
+ffi_conf.set('HAVE_ALLOCA', cc.has_function('alloca'))
+ffi_conf.set10('HAVE_MEMCPY', cc.has_function('memcpy'))
+ffi_conf.set('HAVE_MKOSTEMP', cc.has_function('mkostemp'))
+
+# Misc headers
+ffi_conf.set10('HAVE_ALLOCA_H', cc.has_header('alloca.h'))
+ffi_conf.set('HAVE_INTTYPES_H', cc.has_header('inttypes.h'))
+ffi_conf.set('HAVE_STDINT_H', cc.has_header('stdint.h'))
+# Checks in the configure file that aren't used
+#ffi_conf.set10('HAVE_DLFCN_H', cc.has_header('dlfcn.h'))
+#ffi_conf.set10('HAVE_MEMORY_H', cc.has_header('memory.h'))
+#ffi_conf.set10('HAVE_STDLIB_H', cc.has_header('stdlib.h'))
+#ffi_conf.set10('HAVE_STRING_H', cc.has_header('string.h'))
+#ffi_conf.set10('HAVE_STRINGS_H', cc.has_header('strings.h'))
+#ffi_conf.set10('HAVE_SYS_MMAN_H', cc.has_header('sys/mman.h'))
+#ffi_conf.set10('HAVE_SYS_STAT_H', cc.has_header('sys/stat.h'))
+#ffi_conf.set10('HAVE_SYS_TYPES_H', cc.has_header('sys/types.h'))
+#ffi_conf.set10('HAVE_UNISTD_H', cc.has_header('unistd.h'))
+
+# Misc defines
+# FIXME: Check if this is compiler-specific check is correct
+if host_system != 'windows'
+  message('Host system is not Windows; assuming .hidden pseudo-op is available')
+  ffi_conf.set('HAVE_HIDDEN_VISIBILITY_ATTRIBUTE', 1)
+endif
+
+# User options
+if get_option('debug')
+  ffi_conf.set('FFI_DEBUG')
+endif
+if not get_option('raw_api')
+  ffi_conf.set('FFI_NO_RAW_API', 1)
+endif
+if not get_option('structs')
+  ffi_conf.set('FFI_NO_STRUCTS', 1)
+endif
+if get_option('purify_safety')
+  ffi_conf.set('USING_PURIFY', 1)
+endif
+if get_option('pax_emutramp')
+  ffi_conf.set('FFI_MMAP_EXEC_EMUTRAMP_PAX', 1)
+endif
+
+msvcc = find_program('msvcc.sh')
+
+# pkg-config file
+ffi_pc_conf = configuration_data()
+ffi_pc_conf.set('prefix', get_option('prefix'))
+ffi_pc_conf.set('exec_prefix', get_option('prefix'))
+ffi_pc_conf.set('libdir', '@0@/@1@'.format(get_option('prefix'), get_option('libdir')))
+ffi_pc_conf.set('includedir', '@0@/include'.format(get_option('prefix')))
+ffi_pc_conf.set('PACKAGE_VERSION', meson.project_version())
+pkgconfigdir = get_option('libdir') + '/pkgconfig'
+configure_file(input : 'libffi.pc.in', output : 'libffi.pc',
+  configuration : ffi_pc_conf,
+  install_dir : pkgconfigdir)
+
+ffiinc = [include_directories('.'), include_directories('include')]
+
+# Configure ffi_conf some more and declare libffi.so
+subdir('src')
+
+# Configure and install headers
+subdir('include')
+
+# Configure fficonfig.h (not installed)
+configure_file(input : 'fficonfig.h.meson', output : 'fficonfig.h',
+  configuration : ffi_conf)
+
+# TODO: Install texinfo files
+install_man([
+  'man/ffi.3',
+  'man/ffi_call.3',
+  'man/ffi_prep_cif.3',
+  'man/ffi_prep_cif_var.3'])
diff --git a/meson_options.txt b/meson_options.txt
new file mode 100644
index 0000000..7e5bede
--- /dev/null
+++ b/meson_options.txt
@@ -0,0 +1,11 @@
+# Toggle this if you want extra debugging
+option('debug', type : 'boolean', value : false)
+# Toggle this if you do not want support for aggregate types
+option('structs', type : 'boolean', value : true)
+# Toggle this if you do not want support for the raw API
+option('raw_api', type : 'boolean', value : true)
+# Toggle this if you are using Purify and want to suppress spurious messages
+option('purify_safety', type : 'boolean', value : false)
+# Toggle this if you want to enable pax emulated trampolines for PaX kernels
+# On PaX enable kernels that have MPROTECT enabled we can't use PROT_EXEC
+option('pax_emutramp', type : 'boolean', value : false)
diff --git a/src/meson.build b/src/meson.build
new file mode 100644
index 0000000..de53c42
--- /dev/null
+++ b/src/meson.build
@@ -0,0 +1,234 @@
+ffi_c_sources = [
+  'prep_cif.c',
+  'types.c',
+  'raw_api.c',
+  'java_raw_api.c',
+  'closures.c',
+]
+
+ffi_asm_sources = []
+
+if get_option('debug')
+  ffi_c_sources += ['debug.c']
+endif
+
+arch_subdir = host_cpu_family
+if host_cpu_family == 'mips'
+  ffi_conf.set('TARGET', 'MIPS')
+  ffi_c_sources += ['mips/ffi.c']
+  ffi_asm_sources += ['mips/o32.S', 'mips/n32.S']
+elif host_cpu_family == 'blackfin'
+  ffi_conf.set('TARGET', 'BFIN')
+  arch_subdir = 'bfin'
+  ffi_c_sources += ['bfin/ffi.c']
+  ffi_asm_sources += ['bfin/sysv.S']
+elif host_cpu_family == 'x86_64'
+  arch_subdir = 'x86'
+  ffi_c_sources += ['x86/ffi.c']
+  if host_system == 'windows'
+    ffi_conf.set('TARGET', 'X86_WIN64')
+    ffi_asm_sources += ['x86/win64.S']
+  elif host_system == 'darwin'
+    ffi_conf.set('TARGET', 'X86_DARWIN')
+    ffi_c_sources += ['x86/ffi64.c']
+    ffi_asm_sources += ['x86/darwin.S', 'x86/darwin64.S']
+  elif size_t == 4
+    ffi_conf.set('TARGET', 'X86')
+    ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
+  else
+    ffi_conf.set('TARGET', 'X86_64')
+    ffi_c_sources += ['x86/ffi64.c']
+    ffi_asm_sources += ['x86/unix64.S', 'x86/sysv.S']
+  # FIXME: Doesn't support x32
+  endif
+elif host_cpu_family == 'x86'
+  ffi_c_sources += ['x86/ffi.c']
+  # FIXME: This isn't quite correct. Compare with configure.ac
+  if host_system == 'freebsd'
+    ffi_conf.set('TARGET', 'X86_FREEBSD')
+    ffi_asm_sources += ['x86/freebsd.S', 'x86/win32.S']
+  elif host_system == 'windows'
+    ffi_conf.set('TARGET', 'X86_WIN32')
+    ffi_asm_sources += ['x86/win32.S']
+  elif host_system == 'darwin'
+    ffi_conf.set('TARGET', 'X86_DARWIN')
+    ffi_c_sources += ['x86/ffi64.c']
+    ffi_asm_sources += ['x86/darwin.S', 'x86/darwin64.S']
+    if size_t == 4
+      ffi_conf.set('TARGET', 'X86_DARWIN32')
+      ffi_asm_sources += ['x86/win32.S']
+    else
+      ffi_conf.set('TARGET', 'X86_DARWIN64')
+    endif
+  elif host_system == 'solaris'
+    if size_t == 4
+      ffi_conf.set('TARGET', 'X86')
+      ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
+    else
+      ffi_conf.set('TARGET', 'X86_64')
+      ffi_c_sources += ['x86/ffi64.c', 'x86/unix64.c', 'x86/ffi.c']
+  ffi_asm_sources += ['x86/sysv.S']
+    endif
+  elif size_t == 4
+    ffi_conf.set('TARGET', 'X86')
+    ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
+  else
+    error('Unsupported cpu/host/size_t combination: x86 but size_t != 4')
+  # FIXME: Doesn't support x32
+  endif
+elif host_cpu_family == 'sparc'
+  ffi_conf.set('TARGET', 'SPARC')
+  ffi_c_sources += ['sparc/ffi.c']
+  ffi_asm_sources += ['sparc/v8.S', 'sparc/v9.S']
+elif host_cpu_family == 'alpha'
+  ffi_conf.set('TARGET', 'ALPHA')
+  ffi_c_sources += ['alpha/ffi.c']
+  ffi_asm_sources += ['alpha/osf.S']
+elif host_cpu_family == 'ia64'
+  ffi_conf.set('TARGET', 'IA64')
+  ffi_c_sources += ['ia64/ffi.c']
+  ffi_asm_sources += ['ia64/unix.S']
+elif host_cpu_family == 'm32r'
+  ffi_conf.set('TARGET', 'M32R')
+  ffi_c_sources += ['m32r/ffi.c']
+  ffi_asm_sources += ['m32r/sysv.S']
+elif host_cpu_family == 'm68k'
+  ffi_conf.set('TARGET', 'M68K')
+  ffi_c_sources += ['m68k/ffi.c']
+  ffi_asm_sources += ['m68k/sysv.S']
+elif host_cpu_family == 'm88k'
+  ffi_conf.set('TARGET', 'M88K')
+  ffi_c_sources += ['m88k/ffi.c']
+  ffi_asm_sources += ['m88k/obsd.S']
+elif host_cpu_family == 'moxie'
+  ffi_conf.set('TARGET', 'MOXIE')
+  ffi_c_sources += ['moxie/ffi.c']
+  ffi_asm_sources += ['moxie/eabi.S']
+elif host_cpu_family == 'microblaze'
+  ffi_conf.set('TARGET', 'MICROBLAZE')
+  ffi_c_sources += ['microblaze/ffi.c']
+  ffi_asm_sources += ['microblaze/sysv.S']
+elif host_cpu_family == 'nios2'
+  ffi_conf.set('TARGET', 'NIOS2')
+  ffi_c_sources += ['nios2/ffi.c']
+  ffi_asm_sources += ['nios2/sysv.S']
+elif host_cpu_family == 'or1k'
+  ffi_conf.set('TARGET', 'OR1K')
+  ffi_c_sources += ['or1k/ffi.c']
+  ffi_asm_sources += ['or1k/sysv.S']
+elif host_cpu_family == 'powerpc'
+  if host_system == 'aix'
+    ffi_conf.set('TARGET', 'POWERPC_AIX')
+    ffi_c_sources += ['powerpc/ffi_darwin.c']
+    ffi_asm_sources += ['powerpc/aix.S', 'powerpc/aix_closure.S']
+  elif host_system == 'freebsd'
+    ffi_conf.set('TARGET', 'POWERPC_FREEBSD')
+    ffi_c_sources += ['powerpc/ffi.c', 'powerpc/ffi_sysv.c']
+    ffi_asm_sources += ['powerpc/sysv.S', 'powerpc/ppc_closure.S']
+  elif host_system == 'darwin'
+    ffi_conf.set('TARGET', 'POWERPC_DARWIN')
+    ffi_c_sources += ['powerpc/ffi_darwin.c']
+    ffi_asm_sources += ['powerpc/darwin.S', 'powerpc/darwin_closure.S']
+  else
+    ffi_conf.set('TARGET', 'POWERPC')
+    ffi_c_sources += ['powerpc/ffi.c', 'powerpc/ffi_sysv.c', 'powerpc/ffi_linux64.c']
+    ffi_asm_sources += ['powerpc/sysv.S', 'powerpc/ppc_closure.S', 'powerpc/linux64.S', 'powerpc/linux64_closure.S']
+  endif
+elif host_cpu_family == 'aarch64'
+  ffi_conf.set('TARGET', 'AARCH64')
+  ffi_c_sources += ['aarch64/ffi.c']
+  ffi_asm_sources += ['aarch64/sysv.S']
+elif host_cpu_family == 'arc'
+  ffi_conf.set('TARGET', 'ARC')
+  ffi_c_sources += ['arc/ffi.c']
+  ffi_asm_sources += ['arc/arcompact.S']
+elif host_cpu_family == 'arm'
+  ffi_conf.set('TARGET', 'ARM')
+  ffi_c_sources += ['arm/ffi.c']
+  ffi_asm_sources += ['arm/sysv.S']
+  if host_system == 'darwin'
+    ffi_asm_sources += ['arm/trampoline.S']
+  endif
+elif host_cpu_family == 'avr32'
+  ffi_conf.set('TARGET', 'AVR32')
+  ffi_c_sources += ['avr32/ffi.c']
+  ffi_asm_sources += ['avr32/sysv.S']
+elif host_cpu_family == 'cris'
+  ffi_conf.set('TARGET', 'LIBFFI_CRIS')
+  ffi_c_sources += ['cris/ffi.c']
+  ffi_asm_sources += ['cris/sysv.S']
+elif host_cpu_family == 'frv'
+  ffi_conf.set('TARGET', 'FRV')
+  ffi_c_sources += ['frv/ffi.c']
+  ffi_asm_sources += ['frv/eabi.S']
+elif host_cpu_family == 's390'
+  ffi_conf.set('TARGET', 'S390')
+  ffi_c_sources += ['s390/ffi.c']
+  ffi_asm_sources += ['s390/sysv.S']
+elif host_cpu_family == 'sh'
+  ffi_conf.set('TARGET', 'SH')
+  ffi_c_sources += ['sh/ffi.c']
+  ffi_asm_sources += ['sh/sysv.S']
+elif host_cpu_family == 'sh64'
+  ffi_conf.set('TARGET', 'SH64')
+  ffi_c_sources += ['sh64/ffi.c']
+  ffi_asm_sources += ['sh64/sysv.S']
+elif host_cpu_family == 'pa'
+  if host_system == 'hpux'
+    ffi_conf.set('TARGET', 'PA_HPUX')
+    ffi_c_sources += ['pa/ffi.c']
+  ffi_asm_sources += ['pa/hpux32.S']
+  else
+    ffi_conf.set('TARGET', 'PA_LINUX')
+    ffi_c_sources += ['pa/ffi.c']
+  ffi_asm_sources += ['pa/linux.S']
+  endif
+elif host_cpu_family == 'tile'
+  ffi_conf.set('TARGET', 'TILE')
+  ffi_c_sources += ['tile/ffi.c']
+  ffi_asm_sources += ['tile/tile.S']
+elif host_cpu_family == 'xtensa'
+  ffi_conf.set('TARGET', 'XTENSA')
+  ffi_c_sources += ['xtensa/ffi.c']
+  ffi_asm_sources += ['xtensa/sysv.S']
+elif host_cpu_family == 'metag'
+  ffi_conf.set('TARGET', 'METAG')
+  ffi_c_sources += ['metag/ffi.c']
+  ffi_asm_sources += ['metag/sysv.S']
+elif host_cpu_family == 'vax'
+  ffi_conf.set('TARGET', 'VAX')
+  ffi_c_sources += ['vax/ffi.c']
+  ffi_asm_sources += ['vax/elfbsd.S']
+else
+  error('Unsupported cpu family: ' + host_cpu_family)
+endif
+
+if cc.get_id() == 'msvc'
+  # FIXME: Meson doesn't have built-in support for compiling assembly files.
+  # Use the msvcc.sh script to compile the ASM sources.
+  #
+  # GCC and Clang accept assembly files directly, but MSVC's cl.exe does not.
+  # You need to manually pass the files through the pre-processor first and
+  # then through the assembler. I tried a whole bunch of things including
+  # generators for both (didn't work because generators can't take generator
+  # output as input), custom_target() for both (didn't work because the format
+  # required is very specific, custom_target is processed during configure,
+  # etc). Finally, I gave up and did this.
+  args = ['-c', '-I.', '-Iinclude']
+  if host_cpu_family == 'x86_64'
+    args += ['-m64'] # msvcc.sh checks this gcc flag to switch to 64-bit mode
+  endif
+  compiler = generator(msvcc,
+      output : '@BASENAME@.obj',
+      arguments : ['@INPUT@'] + args + ['-o', '@OUTPUT0@'])
+  ffi_asm_sources = compiler.process(ffi_asm_sources)
+endif
+
+ffi_lib = library('ffi', ffi_c_sources, ffi_asm_sources,
+  include_directories : ffiinc,
+  # Taken from the libtool-version file
+  # current.revision.age
+  version : '6.0.4',
+  # current
+  soversion : '6',
+  install : true)
-- 
2.12.2.windows.2


From edaa2f7f5726efa2efe33335493e81e6715d7a82 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Sat, 16 Apr 2016 02:57:14 +0530
Subject: [PATCH 02/11] Export all public function symbols when building on
 MSVC

---
 include/ffi.h.in | 70 ++++++++++++++++++++++++++++++++------------------------
 meson.build      |  3 +++
 2 files changed, 43 insertions(+), 30 deletions(-)

diff --git a/include/ffi.h.in b/include/ffi.h.in
index d76d8e6..ac79f2f 100644
--- a/include/ffi.h.in
+++ b/include/ffi.h.in
@@ -57,6 +57,23 @@ extern "C" {
 
 #include <ffitarget.h>
 
+/* Need minimal decorations for DLLs to works on Windows.  GCC has
+   autoimport and autoexport.  Rely on Libtool to help MSVC export
+   from a DLL, but always declare data to be imported for MSVC
+   clients.  This costs an extra indirection for MSVC clients using
+   the static version of the library, but don't worry about that.
+   Besides, as a workaround, they can define FFI_BUILDING if they
+   *know* they are going to link with the static library.  */
+#if defined _WIN32 && !defined FFI_STATIC_BUILD
+#ifdef FFI_BUILDING
+#define FFI_EXTERN __declspec(dllexport)
+#else
+#define FFI_EXTERN __declspec(dllimport)
+#endif
+#else
+#define FFI_EXTERN extern
+#endif
+
 #ifndef LIBFFI_ASM
 
 #if defined(_MSC_VER) && !defined(__clang__)
@@ -157,19 +174,6 @@ typedef struct _ffi_type
  #error "long size not supported"
 #endif
 
-/* Need minimal decorations for DLLs to works on Windows.  GCC has
-   autoimport and autoexport.  Rely on Libtool to help MSVC export
-   from a DLL, but always declare data to be imported for MSVC
-   clients.  This costs an extra indirection for MSVC clients using
-   the static version of the library, but don't worry about that.
-   Besides, as a workaround, they can define FFI_BUILDING if they
-   *know* they are going to link with the static library.  */
-#if defined _MSC_VER && !defined FFI_BUILDING
-#define FFI_EXTERN extern __declspec(dllimport)
-#else
-#define FFI_EXTERN extern
-#endif
-
 /* These are defined in types.c.  */
 FFI_EXTERN ffi_type ffi_type_void;
 FFI_EXTERN ffi_type ffi_type_uint8;
@@ -255,28 +259,28 @@ typedef union {
 typedef ffi_raw ffi_java_raw;
 #endif
 
-
+FFI_EXTERN
 void ffi_raw_call (ffi_cif *cif,
 		   void (*fn)(void),
 		   void *rvalue,
 		   ffi_raw *avalue);
 
-void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
-void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
-size_t ffi_raw_size (ffi_cif *cif);
+FFI_EXTERN void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
+FFI_EXTERN void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
+FFI_EXTERN size_t ffi_raw_size (ffi_cif *cif);
 
 /* This is analogous to the raw API, except it uses Java parameter
    packing, even on 64-bit machines.  I.e. on 64-bit machines longs
    and doubles are followed by an empty 64-bit word.  */
-
+FFI_EXTERN
 void ffi_java_raw_call (ffi_cif *cif,
 			void (*fn)(void),
 			void *rvalue,
 			ffi_java_raw *avalue);
 
-void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);
-void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);
-size_t ffi_java_raw_size (ffi_cif *cif);
+FFI_EXTERN void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);
+FFI_EXTERN void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);
+FFI_EXTERN size_t ffi_java_raw_size (ffi_cif *cif);
 
 /* ---- Definitions for closures ----------------------------------------- */
 
@@ -307,10 +311,10 @@ typedef struct {
 # endif
 #endif
 
-void *ffi_closure_alloc (size_t size, void **code);
-void ffi_closure_free (void *);
+FFI_EXTERN void *ffi_closure_alloc (size_t size, void **code);
+FFI_EXTERN void ffi_closure_free (void *);
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_closure (ffi_closure*,
 		  ffi_cif *,
 		  void (*fun)(ffi_cif*,void*,void**,void*),
@@ -322,7 +326,7 @@ ffi_prep_closure (ffi_closure*,
 #endif
   ;
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_closure_loc (ffi_closure*,
 		      ffi_cif *,
 		      void (*fun)(ffi_cif*,void*,void**,void*),
@@ -383,26 +387,26 @@ typedef struct {
 
 } ffi_java_raw_closure;
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_raw_closure (ffi_raw_closure*,
 		      ffi_cif *cif,
 		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
 		      void *user_data);
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_raw_closure_loc (ffi_raw_closure*,
 			  ffi_cif *cif,
 			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
 			  void *user_data,
 			  void *codeloc);
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_java_raw_closure (ffi_java_raw_closure*,
 		           ffi_cif *cif,
 		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
 		           void *user_data);
 
-ffi_status
+FFI_EXTERN ffi_status
 ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
 			       ffi_cif *cif,
 			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
@@ -419,9 +423,11 @@ typedef struct {
   void     (*fun)(ffi_cif*,void*,void**,void*);
 } ffi_go_closure;
 
+FFI_EXTERN
 ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,
 				void (*fun)(ffi_cif*,void*,void**,void*));
 
+FFI_EXTERN
 void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
 		  void **avalue, void *closure);
 
@@ -429,12 +435,14 @@ void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,
 
 /* ---- Public interface definition -------------------------------------- */
 
+FFI_EXTERN
 ffi_status ffi_prep_cif(ffi_cif *cif,
 			ffi_abi abi,
 			unsigned int nargs,
 			ffi_type *rtype,
 			ffi_type **atypes);
 
+FFI_EXTERN
 ffi_status ffi_prep_cif_var(ffi_cif *cif,
 			    ffi_abi abi,
 			    unsigned int nfixedargs,
@@ -442,11 +450,13 @@ ffi_status ffi_prep_cif_var(ffi_cif *cif,
 			    ffi_type *rtype,
 			    ffi_type **atypes);
 
+FFI_EXTERN
 void ffi_call(ffi_cif *cif,
 	      void (*fn)(void),
 	      void *rvalue,
 	      void **avalue);
 
+FFI_EXTERN
 ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
 				   size_t *offsets);
 
@@ -455,7 +465,7 @@ ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,
 
 /* ---- Definitions shared with assembly code ---------------------------- */
 
-#endif
+#endif /* !LIBFFI_ASM */
 
 /* If these change, update src/mips/ffitarget.h. */
 #define FFI_TYPE_VOID       0    
diff --git a/meson.build b/meson.build
index d5bb2e8..f137bc4 100644
--- a/meson.build
+++ b/meson.build
@@ -5,6 +5,9 @@ project('libffi', 'c', version : '3.2.1',
 
 cc = meson.get_compiler('c')
 
+# For FFI_EXTERN symbol exporting
+add_global_arguments('-DFFI_BUILDING', language : 'c')
+
 ffi_conf = configuration_data()
 
 # NOTE: host = "cross" or "target"
-- 
2.12.2.windows.2


From faa2744c7f05a742dd972d38564d89a74cb8a802 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Mon, 27 Feb 2017 17:42:55 +0530
Subject: [PATCH 03/11] Rebase against latest master, and fix MSVC support

* Reinstate win32 MSVC support from the last-known-good commit:
  20562ac0427c3578250d04c6e34fb0127d4551cf
  This is in the form of ffiold_msvc.c and win32_msvc.S

* Upstream has MSVC support now, via win64_intel.S which is
  a translation of win64.S from GAS to Intel syntax.

* Nuke "support" archs that we aren't testing gstreamer meson builds on.
  At present this is just Linux/Windows, x86/x86_64.

* Use custom_targets instead of msvcc.sh for building assembly sources
  with MSVC
---
 src/meson.build       | 257 +++-----------
 src/x86/ffiold-msvc.c | 931 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/x86/win32_msvc.S  | 519 ++++++++++++++++++++++++++++
 3 files changed, 1506 insertions(+), 201 deletions(-)
 create mode 100644 src/x86/ffiold-msvc.c
 create mode 100644 src/x86/win32_msvc.S

diff --git a/src/meson.build b/src/meson.build
index de53c42..b747948 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -12,223 +12,78 @@ if get_option('debug')
   ffi_c_sources += ['debug.c']
 endif
 
-arch_subdir = host_cpu_family
-if host_cpu_family == 'mips'
-  ffi_conf.set('TARGET', 'MIPS')
-  ffi_c_sources += ['mips/ffi.c']
-  ffi_asm_sources += ['mips/o32.S', 'mips/n32.S']
-elif host_cpu_family == 'blackfin'
-  ffi_conf.set('TARGET', 'BFIN')
-  arch_subdir = 'bfin'
-  ffi_c_sources += ['bfin/ffi.c']
-  ffi_asm_sources += ['bfin/sysv.S']
-elif host_cpu_family == 'x86_64'
-  arch_subdir = 'x86'
-  ffi_c_sources += ['x86/ffi.c']
-  if host_system == 'windows'
-    ffi_conf.set('TARGET', 'X86_WIN64')
-    ffi_asm_sources += ['x86/win64.S']
-  elif host_system == 'darwin'
-    ffi_conf.set('TARGET', 'X86_DARWIN')
-    ffi_c_sources += ['x86/ffi64.c']
-    ffi_asm_sources += ['x86/darwin.S', 'x86/darwin64.S']
-  elif size_t == 4
-    ffi_conf.set('TARGET', 'X86')
-    ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
-  else
-    ffi_conf.set('TARGET', 'X86_64')
-    ffi_c_sources += ['x86/ffi64.c']
-    ffi_asm_sources += ['x86/unix64.S', 'x86/sysv.S']
-  # FIXME: Doesn't support x32
-  endif
-elif host_cpu_family == 'x86'
-  ffi_c_sources += ['x86/ffi.c']
-  # FIXME: This isn't quite correct. Compare with configure.ac
-  if host_system == 'freebsd'
-    ffi_conf.set('TARGET', 'X86_FREEBSD')
-    ffi_asm_sources += ['x86/freebsd.S', 'x86/win32.S']
-  elif host_system == 'windows'
-    ffi_conf.set('TARGET', 'X86_WIN32')
-    ffi_asm_sources += ['x86/win32.S']
-  elif host_system == 'darwin'
-    ffi_conf.set('TARGET', 'X86_DARWIN')
-    ffi_c_sources += ['x86/ffi64.c']
-    ffi_asm_sources += ['x86/darwin.S', 'x86/darwin64.S']
-    if size_t == 4
-      ffi_conf.set('TARGET', 'X86_DARWIN32')
-      ffi_asm_sources += ['x86/win32.S']
+# We only support x86 on Windows and Linux right now
+arch_subdir = 'x86'
+if host_system == 'windows'
+  # No ARM support for Windows in libffi
+  if size_t == 4
+    TARGET = 'X86_WIN32'
+    if cc.get_id() == 'msvc'
+      ffi_c_sources += ['x86/ffiold-msvc.c']
+      ffi_asm_sources += ['x86/win32_msvc.S']
     else
-      ffi_conf.set('TARGET', 'X86_DARWIN64')
+      ffi_c_sources += ['x86/ffi.c']
+      ffi_asm_sources += ['x86/sysv.S']
     endif
-  elif host_system == 'solaris'
-    if size_t == 4
-      ffi_conf.set('TARGET', 'X86')
-      ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
+  else
+    TARGET = 'X86_WIN64'
+    ffi_c_sources += ['x86/ffiw64.c']
+    if cc.get_id() == 'msvc'
+      ffi_asm_sources += ['x86/win64_intel.S']
     else
-      ffi_conf.set('TARGET', 'X86_64')
-      ffi_c_sources += ['x86/ffi64.c', 'x86/unix64.c', 'x86/ffi.c']
-  ffi_asm_sources += ['x86/sysv.S']
+      ffi_asm_sources += ['x86/win64.S']
     endif
-  elif size_t == 4
-    ffi_conf.set('TARGET', 'X86')
-    ffi_asm_sources += ['x86/sysv.S', 'x86/win32.S']
-  else
-    error('Unsupported cpu/host/size_t combination: x86 but size_t != 4')
-  # FIXME: Doesn't support x32
   endif
-elif host_cpu_family == 'sparc'
-  ffi_conf.set('TARGET', 'SPARC')
-  ffi_c_sources += ['sparc/ffi.c']
-  ffi_asm_sources += ['sparc/v8.S', 'sparc/v9.S']
-elif host_cpu_family == 'alpha'
-  ffi_conf.set('TARGET', 'ALPHA')
-  ffi_c_sources += ['alpha/ffi.c']
-  ffi_asm_sources += ['alpha/osf.S']
-elif host_cpu_family == 'ia64'
-  ffi_conf.set('TARGET', 'IA64')
-  ffi_c_sources += ['ia64/ffi.c']
-  ffi_asm_sources += ['ia64/unix.S']
-elif host_cpu_family == 'm32r'
-  ffi_conf.set('TARGET', 'M32R')
-  ffi_c_sources += ['m32r/ffi.c']
-  ffi_asm_sources += ['m32r/sysv.S']
-elif host_cpu_family == 'm68k'
-  ffi_conf.set('TARGET', 'M68K')
-  ffi_c_sources += ['m68k/ffi.c']
-  ffi_asm_sources += ['m68k/sysv.S']
-elif host_cpu_family == 'm88k'
-  ffi_conf.set('TARGET', 'M88K')
-  ffi_c_sources += ['m88k/ffi.c']
-  ffi_asm_sources += ['m88k/obsd.S']
-elif host_cpu_family == 'moxie'
-  ffi_conf.set('TARGET', 'MOXIE')
-  ffi_c_sources += ['moxie/ffi.c']
-  ffi_asm_sources += ['moxie/eabi.S']
-elif host_cpu_family == 'microblaze'
-  ffi_conf.set('TARGET', 'MICROBLAZE')
-  ffi_c_sources += ['microblaze/ffi.c']
-  ffi_asm_sources += ['microblaze/sysv.S']
-elif host_cpu_family == 'nios2'
-  ffi_conf.set('TARGET', 'NIOS2')
-  ffi_c_sources += ['nios2/ffi.c']
-  ffi_asm_sources += ['nios2/sysv.S']
-elif host_cpu_family == 'or1k'
-  ffi_conf.set('TARGET', 'OR1K')
-  ffi_c_sources += ['or1k/ffi.c']
-  ffi_asm_sources += ['or1k/sysv.S']
-elif host_cpu_family == 'powerpc'
-  if host_system == 'aix'
-    ffi_conf.set('TARGET', 'POWERPC_AIX')
-    ffi_c_sources += ['powerpc/ffi_darwin.c']
-    ffi_asm_sources += ['powerpc/aix.S', 'powerpc/aix_closure.S']
-  elif host_system == 'freebsd'
-    ffi_conf.set('TARGET', 'POWERPC_FREEBSD')
-    ffi_c_sources += ['powerpc/ffi.c', 'powerpc/ffi_sysv.c']
-    ffi_asm_sources += ['powerpc/sysv.S', 'powerpc/ppc_closure.S']
-  elif host_system == 'darwin'
-    ffi_conf.set('TARGET', 'POWERPC_DARWIN')
-    ffi_c_sources += ['powerpc/ffi_darwin.c']
-    ffi_asm_sources += ['powerpc/darwin.S', 'powerpc/darwin_closure.S']
+elif host_system == 'linux' and host_cpu_family.startswith('x86')
+  if size_t == 4
+    # FIXME: gnux32 support?
+    TARGET = 'X86'
+    ffi_c_sources += ['x86/ffi.c']
+    ffi_asm_sources += ['x86/sysv.S']
   else
-    ffi_conf.set('TARGET', 'POWERPC')
-    ffi_c_sources += ['powerpc/ffi.c', 'powerpc/ffi_sysv.c', 'powerpc/ffi_linux64.c']
-    ffi_asm_sources += ['powerpc/sysv.S', 'powerpc/ppc_closure.S', 'powerpc/linux64.S', 'powerpc/linux64_closure.S']
-  endif
-elif host_cpu_family == 'aarch64'
-  ffi_conf.set('TARGET', 'AARCH64')
-  ffi_c_sources += ['aarch64/ffi.c']
-  ffi_asm_sources += ['aarch64/sysv.S']
-elif host_cpu_family == 'arc'
-  ffi_conf.set('TARGET', 'ARC')
-  ffi_c_sources += ['arc/ffi.c']
-  ffi_asm_sources += ['arc/arcompact.S']
-elif host_cpu_family == 'arm'
-  ffi_conf.set('TARGET', 'ARM')
-  ffi_c_sources += ['arm/ffi.c']
-  ffi_asm_sources += ['arm/sysv.S']
-  if host_system == 'darwin'
-    ffi_asm_sources += ['arm/trampoline.S']
+    TARGET = 'X86_64'
+    ffi_c_sources += ['x86/ffi64.c', 'x86/ffiw64.c']
+    ffi_asm_sources += ['x86/unix64.S', 'x86/win64.S']
   endif
-elif host_cpu_family == 'avr32'
-  ffi_conf.set('TARGET', 'AVR32')
-  ffi_c_sources += ['avr32/ffi.c']
-  ffi_asm_sources += ['avr32/sysv.S']
-elif host_cpu_family == 'cris'
-  ffi_conf.set('TARGET', 'LIBFFI_CRIS')
-  ffi_c_sources += ['cris/ffi.c']
-  ffi_asm_sources += ['cris/sysv.S']
-elif host_cpu_family == 'frv'
-  ffi_conf.set('TARGET', 'FRV')
-  ffi_c_sources += ['frv/ffi.c']
-  ffi_asm_sources += ['frv/eabi.S']
-elif host_cpu_family == 's390'
-  ffi_conf.set('TARGET', 'S390')
-  ffi_c_sources += ['s390/ffi.c']
-  ffi_asm_sources += ['s390/sysv.S']
-elif host_cpu_family == 'sh'
-  ffi_conf.set('TARGET', 'SH')
-  ffi_c_sources += ['sh/ffi.c']
-  ffi_asm_sources += ['sh/sysv.S']
-elif host_cpu_family == 'sh64'
-  ffi_conf.set('TARGET', 'SH64')
-  ffi_c_sources += ['sh64/ffi.c']
-  ffi_asm_sources += ['sh64/sysv.S']
-elif host_cpu_family == 'pa'
-  if host_system == 'hpux'
-    ffi_conf.set('TARGET', 'PA_HPUX')
-    ffi_c_sources += ['pa/ffi.c']
-  ffi_asm_sources += ['pa/hpux32.S']
-  else
-    ffi_conf.set('TARGET', 'PA_LINUX')
-    ffi_c_sources += ['pa/ffi.c']
-  ffi_asm_sources += ['pa/linux.S']
-  endif
-elif host_cpu_family == 'tile'
-  ffi_conf.set('TARGET', 'TILE')
-  ffi_c_sources += ['tile/ffi.c']
-  ffi_asm_sources += ['tile/tile.S']
-elif host_cpu_family == 'xtensa'
-  ffi_conf.set('TARGET', 'XTENSA')
-  ffi_c_sources += ['xtensa/ffi.c']
-  ffi_asm_sources += ['xtensa/sysv.S']
-elif host_cpu_family == 'metag'
-  ffi_conf.set('TARGET', 'METAG')
-  ffi_c_sources += ['metag/ffi.c']
-  ffi_asm_sources += ['metag/sysv.S']
-elif host_cpu_family == 'vax'
-  ffi_conf.set('TARGET', 'VAX')
-  ffi_c_sources += ['vax/ffi.c']
-  ffi_asm_sources += ['vax/elfbsd.S']
 else
-  error('Unsupported cpu family: ' + host_cpu_family)
+  error('Unsupported system "@0@" or cpu family "@1@"'.format(host_system, host_cpu_family))
 endif
 
+# Used in ffi.h.in to generate ffi-$arch.h
+ffi_conf.set('TARGET', TARGET)
+
 if cc.get_id() == 'msvc'
-  # FIXME: Meson doesn't have built-in support for compiling assembly files.
-  # Use the msvcc.sh script to compile the ASM sources.
-  #
   # GCC and Clang accept assembly files directly, but MSVC's cl.exe does not.
   # You need to manually pass the files through the pre-processor first and
-  # then through the assembler. I tried a whole bunch of things including
-  # generators for both (didn't work because generators can't take generator
-  # output as input), custom_target() for both (didn't work because the format
-  # required is very specific, custom_target is processed during configure,
-  # etc). Finally, I gave up and did this.
-  args = ['-c', '-I.', '-Iinclude']
-  if host_cpu_family == 'x86_64'
-    args += ['-m64'] # msvcc.sh checks this gcc flag to switch to 64-bit mode
-  endif
-  compiler = generator(msvcc,
-      output : '@BASENAME@.obj',
-      arguments : ['@INPUT@'] + args + ['-o', '@OUTPUT0@'])
-  ffi_asm_sources = compiler.process(ffi_asm_sources)
+  # then through the assembler, and then link the objects into the target.
+  # FIXME: Add native support in Meson for this.
+  cl = find_program('cl')
+  ml = find_program('ml', 'ml64')
+  ffi_asm_objs = []
+  foreach asm_source : ffi_asm_sources
+    preproc_name = asm_source.underscorify() + '.i'
+    obj_name = asm_source.underscorify() + '.obj'
+    preproc = custom_target(preproc_name,
+        input : asm_source,
+        output : preproc_name,
+        command : [cl, '/nologo', '/EP', '/P', '/Fi@OUTPUT@',
+                   '/I.', '/I..', '/Iinclude', '/I..\\include',
+                   '/DTARGET=' + TARGET, '/DFFI_BUILDING',
+                   '@INPUT@'])
+    ffi_asm_objs += custom_target(obj_name,
+        input : preproc,
+        output : obj_name,
+        command : [ml, '/Fo', '@OUTPUT@', '/c', '@INPUT@'])
+  endforeach
+  ffi_asm_sources = ffi_asm_objs
 endif
 
 ffi_lib = library('ffi', ffi_c_sources, ffi_asm_sources,
+  c_args : '-DTARGET=' + TARGET,
   include_directories : ffiinc,
   # Taken from the libtool-version file
-  # current.revision.age
-  version : '6.0.4',
-  # current
-  soversion : '6',
+  # current - age . age . revision
+  version : '7.1.0',
+  # current - age
+  soversion : '7',
   install : true)
diff --git a/src/x86/ffiold-msvc.c b/src/x86/ffiold-msvc.c
new file mode 100644
index 0000000..006c95d
--- /dev/null
+++ b/src/x86/ffiold-msvc.c
@@ -0,0 +1,931 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.
+           Copyright (c) 2002  Ranjit Mathew
+           Copyright (c) 2002  Bo Thorsen
+           Copyright (c) 2002  Roger Sayle
+           Copyright (C) 2008, 2010  Free Software Foundation, Inc.
+
+   x86 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#if !defined(__x86_64__) || defined(_WIN64) || defined(__CYGWIN__)
+
+#ifdef _WIN64
+#include <windows.h>
+#endif
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+
+unsigned int ffi_prep_args(char *stack, extended_cif *ecif);
+unsigned int ffi_prep_args(char *stack, extended_cif *ecif)
+{
+  register unsigned int i;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+#ifndef X86_WIN64
+  const int cabi = ecif->cif->abi;
+  const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;
+  unsigned int stack_args_count = 0;
+  void *p_stack_data[3];
+  char *argp2 = stack;
+#else
+  #define dir 1
+#endif
+
+  argp = stack;
+
+  if ((ecif->cif->flags == FFI_TYPE_STRUCT
+       || ecif->cif->flags == FFI_TYPE_MS_STRUCT)
+#ifdef X86_WIN64
+      && ((ecif->cif->rtype->size & (1 | 2 | 4 | 8)) == 0)
+#endif
+      )
+    {
+#ifndef X86_WIN64
+      /* For fastcall/thiscall/register this is first register-passed
+         argument.  */
+      if (cabi == FFI_THISCALL || cabi == FFI_FASTCALL || cabi == FFI_REGISTER)
+        {
+          p_stack_data[stack_args_count] = argp;
+          ++stack_args_count;
+        }
+#endif
+
+      *(void **) argp = ecif->rvalue;
+      argp += sizeof(void*);
+    }
+
+  p_arg  = ecif->cif->arg_types;
+  p_argv = ecif->avalue;
+  if (dir < 0)
+    {
+      const int nargs = ecif->cif->nargs - 1;
+      if (nargs > 0)
+      {
+        p_arg  += nargs;
+        p_argv += nargs;
+      }
+    }
+
+  for (i = ecif->cif->nargs;
+       i != 0;
+       i--, p_arg += dir, p_argv += dir)
+    {
+      /* Align if necessary */
+      if ((sizeof(void*) - 1) & (size_t) argp)
+        argp = (char *) ALIGN(argp, sizeof(void*));
+
+      size_t z = (*p_arg)->size;
+
+#ifdef X86_WIN64
+      if (z > FFI_SIZEOF_ARG
+          || ((*p_arg)->type == FFI_TYPE_STRUCT
+              && (z & (1 | 2 | 4 | 8)) == 0)
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+          || ((*p_arg)->type == FFI_TYPE_LONGDOUBLE)
+#endif
+          )
+        {
+          z = FFI_SIZEOF_ARG;
+          *(void **)argp = *p_argv;
+        }
+      else if ((*p_arg)->type == FFI_TYPE_FLOAT)
+        {
+          memcpy(argp, *p_argv, z);
+        }
+      else
+#endif
+      if (z < FFI_SIZEOF_ARG)
+        {
+          z = FFI_SIZEOF_ARG;
+          switch ((*p_arg)->type)
+            {
+            case FFI_TYPE_SINT8:
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_UINT8:
+              *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_SINT16:
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_UINT16:
+              *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_SINT32:
+              *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_UINT32:
+              *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);
+              break;
+
+            case FFI_TYPE_STRUCT:
+              *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);
+              break;
+
+            default:
+              FFI_ASSERT(0);
+            }
+        }
+      else
+        {
+          memcpy(argp, *p_argv, z);
+        }
+
+#ifndef X86_WIN64
+    /* For thiscall/fastcall/register convention register-passed arguments
+       are the first two none-floating-point arguments with a size
+       smaller or equal to sizeof (void*).  */
+    if ((z == FFI_SIZEOF_ARG)
+        && ((cabi == FFI_REGISTER)
+          || (cabi == FFI_THISCALL && stack_args_count < 1)
+          || (cabi == FFI_FASTCALL && stack_args_count < 2))
+        && ((*p_arg)->type != FFI_TYPE_FLOAT && (*p_arg)->type != FFI_TYPE_STRUCT)
+       )
+      {
+        if (dir < 0 && stack_args_count > 2)
+          {
+            /* Iterating arguments backwards, so first register-passed argument
+               will be passed last. Shift temporary values to make place. */
+            p_stack_data[0] = p_stack_data[1];
+            p_stack_data[1] = p_stack_data[2];
+            stack_args_count = 2;
+          }
+
+        p_stack_data[stack_args_count] = argp;
+        ++stack_args_count;
+      }
+#endif
+
+#ifdef X86_WIN64
+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
+#else
+      argp += z;
+#endif
+    }
+
+#ifndef X86_WIN64
+  /* We need to move the register-passed arguments for thiscall/fastcall/register
+     on top of stack, so that those can be moved to registers by call-handler.  */
+  if (stack_args_count > 0)
+    {
+      if (dir < 0 && stack_args_count > 1)
+        {
+          /* Reverse order if iterating arguments backwards */
+          ffi_arg tmp = *(ffi_arg*) p_stack_data[0];
+          *(ffi_arg*) p_stack_data[0] = *(ffi_arg*) p_stack_data[stack_args_count - 1];
+          *(ffi_arg*) p_stack_data[stack_args_count - 1] = tmp;
+        }
+      
+      int i;
+      for (i = 0; i < stack_args_count; i++)
+        {
+          if (p_stack_data[i] != argp2)
+            {
+              ffi_arg tmp = *(ffi_arg*) p_stack_data[i];
+              memmove (argp2 + FFI_SIZEOF_ARG, argp2, (size_t) ((char*) p_stack_data[i] - (char*)argp2));
+              *(ffi_arg *) argp2 = tmp;
+            }
+
+          argp2 += FFI_SIZEOF_ARG;
+        }
+    }
+
+    return stack_args_count;
+#endif
+    return 0;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  unsigned int i;
+  ffi_type **ptr;
+
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_SINT16:
+#ifdef X86_WIN64
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+#endif
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+#ifndef X86_WIN64
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+#endif
+#endif
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_UINT64:
+#ifdef X86_WIN64
+    case FFI_TYPE_POINTER:
+#endif
+      cif->flags = FFI_TYPE_SINT64;
+      break;
+
+    case FFI_TYPE_STRUCT:
+#ifndef X86
+      if (cif->rtype->size == 1)
+        {
+          cif->flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */
+        }
+      else if (cif->rtype->size == 2)
+        {
+          cif->flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */
+        }
+      else if (cif->rtype->size == 4)
+        {
+#ifdef X86_WIN64
+          cif->flags = FFI_TYPE_SMALL_STRUCT_4B;
+#else
+          cif->flags = FFI_TYPE_INT; /* same as int type */
+#endif
+        }
+      else if (cif->rtype->size == 8)
+        {
+          cif->flags = FFI_TYPE_SINT64; /* same as int64 type */
+        }
+      else
+#endif
+        {
+#ifdef X86_WIN32
+          if (cif->abi == FFI_MS_CDECL)
+            cif->flags = FFI_TYPE_MS_STRUCT;
+          else
+#endif
+            cif->flags = FFI_TYPE_STRUCT;
+          /* allocate space for return value pointer */
+          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
+        }
+      break;
+
+    default:
+#ifdef X86_WIN64
+      cif->flags = FFI_TYPE_SINT64;
+      break;
+    case FFI_TYPE_INT:
+      cif->flags = FFI_TYPE_SINT32;
+#else
+      cif->flags = FFI_TYPE_INT;
+#endif
+      break;
+    }
+
+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+    {
+      if (((*ptr)->alignment - 1) & cif->bytes)
+        cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);
+      cif->bytes += (unsigned)ALIGN((*ptr)->size, FFI_SIZEOF_ARG);
+    }
+
+#ifdef X86_WIN64
+  /* ensure space for storing four registers */
+  cif->bytes += 4 * FFI_SIZEOF_ARG;
+#endif
+
+#ifndef X86_WIN32
+#ifndef X86_WIN64
+  if (cif->abi == FFI_SYSV || cif->abi == FFI_UNIX64)
+#endif
+    cif->bytes = (cif->bytes + 15) & ~0xF;
+#endif
+
+  return FFI_OK;
+}
+
+#ifdef X86_WIN64
+extern int
+ffi_call_win64(unsigned int (*)(char *, extended_cif *), extended_cif *,
+               unsigned, unsigned, unsigned *, void (*fn)(void));
+#else
+extern void
+ffi_call_win32(unsigned int (*)(char *, extended_cif *), extended_cif *,
+               unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));
+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,
+                          unsigned, unsigned, unsigned *, void (*fn)(void));
+#endif
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return */
+  /* value address then we need to make one                     */
+
+#ifdef X86_WIN64
+  if (rvalue == NULL
+      && cif->flags == FFI_TYPE_STRUCT
+      && ((cif->rtype->size & (1 | 2 | 4 | 8)) == 0))
+    {
+      ecif.rvalue = alloca((cif->rtype->size + 0xF) & ~0xF);
+    }
+#else
+  if (rvalue == NULL
+      && (cif->flags == FFI_TYPE_STRUCT
+          || cif->flags == FFI_TYPE_MS_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+#endif
+  else
+    ecif.rvalue = rvalue;
+    
+  
+  switch (cif->abi) 
+    {
+#ifdef X86_WIN64
+    case FFI_WIN64:
+      ffi_call_win64(ffi_prep_args, &ecif, cif->bytes,
+                     cif->flags, ecif.rvalue, fn);
+      break;
+#else
+#ifndef X86_WIN32
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,
+                    fn);
+      break;
+#else
+    case FFI_SYSV:
+    case FFI_MS_CDECL:
+#endif
+    case FFI_STDCALL:
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+    case FFI_PASCAL:
+    case FFI_REGISTER:
+      ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,
+                     ecif.rvalue, fn);
+      break;
+#endif
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+
+/** private members **/
+
+/* The following __attribute__((regparm(1))) decorations will have no effect
+   on MSVC or SUNPRO_C -- standard conventions apply. */
+static unsigned int ffi_prep_incoming_args (char *stack, void **ret,
+                                            void** args, ffi_cif* cif);
+void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)
+     __attribute__ ((regparm(1)));
+unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)
+     __attribute__ ((regparm(1)));
+unsigned int FFI_HIDDEN ffi_closure_WIN32_inner (ffi_closure *, void **, void *)
+     __attribute__ ((regparm(1)));
+void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)
+     __attribute__ ((regparm(1)));
+#ifdef X86_WIN32
+void FFI_HIDDEN ffi_closure_raw_THISCALL (ffi_raw_closure *)
+     __attribute__ ((regparm(1)));
+#endif
+#ifndef X86_WIN64
+void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *);
+void FFI_HIDDEN ffi_closure_THISCALL (ffi_closure *);
+void FFI_HIDDEN ffi_closure_FASTCALL (ffi_closure *);
+void FFI_HIDDEN ffi_closure_REGISTER (ffi_closure *);
+#else
+void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);
+#endif
+
+/* This function is jumped to by the trampoline */
+
+#ifdef X86_WIN64
+void * FFI_HIDDEN
+ffi_closure_win64_inner (ffi_closure *closure, void *args) {
+  ffi_cif       *cif;
+  void         **arg_area;
+  void          *result;
+  void          *resp = &result;
+
+  cif         = closure->cif;
+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  
+
+  /* this call will initialize ARG_AREA, such that each
+   * element in that array points to the corresponding 
+   * value on the stack; and if the function returns
+   * a structure, it will change RESP to point to the
+   * structure return address.  */
+
+  ffi_prep_incoming_args(args, &resp, arg_area, cif);
+  
+  (closure->fun) (cif, resp, arg_area, closure->user_data);
+
+  /* The result is returned in rax.  This does the right thing for
+     result types except for floats; we have to 'mov xmm0, rax' in the
+     caller to correct this.
+     TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!
+  */
+  return cif->rtype->size > sizeof(void *) ? resp : *(void **)resp;
+}
+
+#else
+unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))
+ffi_closure_SYSV_inner (ffi_closure *closure, void **respp, void *args)
+{
+  /* our various things...  */
+  ffi_cif       *cif;
+  void         **arg_area;
+
+  cif         = closure->cif;
+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  
+
+  /* this call will initialize ARG_AREA, such that each
+   * element in that array points to the corresponding 
+   * value on the stack; and if the function returns
+   * a structure, it will change RESP to point to the
+   * structure return address.  */
+
+  ffi_prep_incoming_args(args, respp, arg_area, cif);
+
+  (closure->fun) (cif, *respp, arg_area, closure->user_data);
+
+  return cif->flags;
+}
+
+unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))
+ffi_closure_WIN32_inner (ffi_closure *closure, void **respp, void *args)
+{
+  /* our various things...  */
+  ffi_cif       *cif;
+  void         **arg_area;
+  unsigned int   ret;
+
+  cif         = closure->cif;
+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  
+
+  /* this call will initialize ARG_AREA, such that each
+   * element in that array points to the corresponding 
+   * value on the stack; and if the function returns
+   * a structure, it will change RESP to point to the
+   * structure return address.  */
+
+  ret = ffi_prep_incoming_args(args, respp, arg_area, cif);
+
+  (closure->fun) (cif, *respp, arg_area, closure->user_data);
+
+  return ret;
+}
+#endif /* !X86_WIN64 */
+
+static unsigned int
+ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,
+                       ffi_cif *cif)
+{
+  register unsigned int i;
+  register void **p_argv;
+  register char *argp;
+  register ffi_type **p_arg;
+#ifndef X86_WIN64
+  const int cabi = cif->abi;
+  const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;
+  const unsigned int max_stack_count = (cabi == FFI_THISCALL) ? 1
+                                     : (cabi == FFI_FASTCALL) ? 2
+                                     : (cabi == FFI_REGISTER) ? 3
+                                     : 0;
+  unsigned int passed_regs = 0;
+  void *p_stack_data[3] = { stack - 1 };
+#else
+  #define dir 1
+#endif
+
+  argp = stack;
+#ifndef X86_WIN64
+  argp += max_stack_count * FFI_SIZEOF_ARG;
+#endif
+
+  if ((cif->flags == FFI_TYPE_STRUCT
+       || cif->flags == FFI_TYPE_MS_STRUCT)
+#ifdef X86_WIN64
+      && ((cif->rtype->size & (1 | 2 | 4 | 8)) == 0)
+#endif
+      )
+    {
+#ifndef X86_WIN64
+      if (passed_regs < max_stack_count)
+        {
+          *rvalue = *(void**) (stack + (passed_regs*FFI_SIZEOF_ARG));
+          ++passed_regs;
+        }
+      else
+#endif
+        {
+          *rvalue = *(void **) argp;
+          argp += sizeof(void *);
+        }
+    }
+
+#ifndef X86_WIN64
+  /* Do register arguments first  */
+  for (i = 0, p_arg = cif->arg_types; 
+       i < cif->nargs && passed_regs < max_stack_count;
+       i++, p_arg++)
+    {
+      if ((*p_arg)->type == FFI_TYPE_FLOAT
+         || (*p_arg)->type == FFI_TYPE_STRUCT)
+        continue;
+
+      size_t sz = (*p_arg)->size;
+      if(sz == 0 || sz > FFI_SIZEOF_ARG)
+        continue;
+
+      p_stack_data[passed_regs] = avalue + i;
+      avalue[i] = stack + (passed_regs*FFI_SIZEOF_ARG);
+      ++passed_regs;
+    }
+#endif
+
+  p_arg = cif->arg_types;
+  p_argv = avalue;
+  if (dir < 0)
+    {
+      const int nargs = cif->nargs - 1;
+      if (nargs > 0)
+      {
+        p_arg  += nargs;
+        p_argv += nargs;
+      }
+    }
+
+  for (i = cif->nargs;
+       i != 0;
+       i--, p_arg += dir, p_argv += dir)
+    {
+      /* Align if necessary */
+      if ((sizeof(void*) - 1) & (size_t) argp)
+        argp = (char *) ALIGN(argp, sizeof(void*));
+
+      size_t z = (*p_arg)->size;
+
+#ifdef X86_WIN64
+      if (z > FFI_SIZEOF_ARG
+          || ((*p_arg)->type == FFI_TYPE_STRUCT
+              && (z & (1 | 2 | 4 | 8)) == 0)
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+          || ((*p_arg)->type == FFI_TYPE_LONGDOUBLE)
+#endif
+          )
+        {
+          z = FFI_SIZEOF_ARG;
+          *p_argv = *(void **)argp;
+        }
+      else
+#else
+      if (passed_regs > 0
+          && z <= FFI_SIZEOF_ARG
+          && (p_argv == p_stack_data[0]
+            || p_argv == p_stack_data[1]
+            || p_argv == p_stack_data[2]))
+        {
+          /* Already assigned a register value */
+          continue;
+        }
+      else
+#endif
+        {
+          /* because we're little endian, this is what it turns into.   */
+          *p_argv = (void*) argp;
+        }
+
+#ifdef X86_WIN64
+      argp += (z + sizeof(void*) - 1) & ~(sizeof(void*) - 1);
+#else
+      argp += z;
+#endif
+    }
+
+  return (size_t)argp - (size_t)stack;
+}
+
+#define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \
+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \
+   void*  __fun = (void*)(FUN); \
+   void*  __ctx = (void*)(CTX); \
+   *(unsigned char*) &__tramp[0] = 0x41; \
+   *(unsigned char*) &__tramp[1] = 0xbb; \
+   *(unsigned int*) &__tramp[2] = MASK; /* mov $mask, %r11 */ \
+   *(unsigned char*) &__tramp[6] = 0x48; \
+   *(unsigned char*) &__tramp[7] = 0xb8; \
+   *(void**) &__tramp[8] = __ctx; /* mov __ctx, %rax */ \
+   *(unsigned char *)  &__tramp[16] = 0x49; \
+   *(unsigned char *)  &__tramp[17] = 0xba; \
+   *(void**) &__tramp[18] = __fun; /* mov __fun, %r10 */ \
+   *(unsigned char *)  &__tramp[26] = 0x41; \
+   *(unsigned char *)  &__tramp[27] = 0xff; \
+   *(unsigned char *)  &__tramp[28] = 0xe2; /* jmp %r10 */ \
+ }
+
+/* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */
+
+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \
+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \
+   unsigned int  __fun = (unsigned int)(FUN); \
+   unsigned int  __ctx = (unsigned int)(CTX); \
+   unsigned int  __dis = __fun - (__ctx + 10);  \
+   *(unsigned char*) &__tramp[0] = 0xb8; \
+   *(unsigned int*)  &__tramp[1] = __ctx; /* movl __ctx, %eax */ \
+   *(unsigned char*) &__tramp[5] = 0xe9; \
+   *(unsigned int*)  &__tramp[6] = __dis; /* jmp __fun  */ \
+ }
+
+#define FFI_INIT_TRAMPOLINE_RAW_THISCALL(TRAMP,FUN,CTX,SIZE) \
+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \
+   unsigned int  __fun = (unsigned int)(FUN); \
+   unsigned int  __ctx = (unsigned int)(CTX); \
+   unsigned int  __dis = __fun - (__ctx + 49);  \
+   unsigned short __size = (unsigned short)(SIZE); \
+   *(unsigned int *) &__tramp[0] = 0x8324048b;      /* mov (%esp), %eax */ \
+   *(unsigned int *) &__tramp[4] = 0x4c890cec;      /* sub $12, %esp */ \
+   *(unsigned int *) &__tramp[8] = 0x04890424;      /* mov %ecx, 4(%esp) */ \
+   *(unsigned char*) &__tramp[12] = 0x24;           /* mov %eax, (%esp) */ \
+   *(unsigned char*) &__tramp[13] = 0xb8; \
+   *(unsigned int *) &__tramp[14] = __size;         /* mov __size, %eax */ \
+   *(unsigned int *) &__tramp[18] = 0x08244c8d;     /* lea 8(%esp), %ecx */ \
+   *(unsigned int *) &__tramp[22] = 0x4802e8c1;     /* shr $2, %eax ; dec %eax */ \
+   *(unsigned short*) &__tramp[26] = 0x0b74;        /* jz 1f */ \
+   *(unsigned int *) &__tramp[28] = 0x8908518b;     /* 2b: mov 8(%ecx), %edx */ \
+   *(unsigned int *) &__tramp[32] = 0x04c18311;     /* mov %edx, (%ecx) ; add $4, %ecx */ \
+   *(unsigned char*) &__tramp[36] = 0x48;           /* dec %eax */ \
+   *(unsigned short*) &__tramp[37] = 0xf575;        /* jnz 2b ; 1f: */ \
+   *(unsigned char*) &__tramp[39] = 0xb8; \
+   *(unsigned int*)  &__tramp[40] = __ctx;          /* movl __ctx, %eax */ \
+   *(unsigned char *)  &__tramp[44] = 0xe8; \
+   *(unsigned int*)  &__tramp[45] = __dis;          /* call __fun  */ \
+   *(unsigned char*)  &__tramp[49] = 0xc2;          /* ret  */ \
+   *(unsigned short*)  &__tramp[50] = (__size + 8); /* ret (__size + 8)  */ \
+ }
+
+#define FFI_INIT_TRAMPOLINE_WIN32(TRAMP,FUN,CTX)  \
+{ unsigned char *__tramp = (unsigned char*)(TRAMP); \
+   unsigned int  __fun = (unsigned int)(FUN); \
+   unsigned int  __ctx = (unsigned int)(CTX); \
+   unsigned int  __dis = __fun - (__ctx + 10); \
+   *(unsigned char*) &__tramp[0] = 0x68; \
+   *(unsigned int*)  &__tramp[1] = __ctx; /* push __ctx */ \
+   *(unsigned char*) &__tramp[5] = 0xe9; \
+   *(unsigned int*)  &__tramp[6] = __dis; /* jmp __fun  */ \
+ }
+
+/* the cif must already be prep'ed */
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+#ifdef X86_WIN64
+#define ISFLOAT(IDX) (cif->arg_types[IDX]->type == FFI_TYPE_FLOAT || cif->arg_types[IDX]->type == FFI_TYPE_DOUBLE)
+#define FLAG(IDX) (cif->nargs>(IDX)&&ISFLOAT(IDX)?(1<<(IDX)):0)
+  if (cif->abi == FFI_WIN64) 
+    {
+      int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);
+      FFI_INIT_TRAMPOLINE_WIN64 (&closure->tramp[0],
+                                 &ffi_closure_win64,
+                                 codeloc, mask);
+      /* make sure we can execute here */
+    }
+#else
+  if (cif->abi == FFI_SYSV)
+    {
+      FFI_INIT_TRAMPOLINE (&closure->tramp[0],
+                           &ffi_closure_SYSV,
+                           (void*)codeloc);
+    }
+  else if (cif->abi == FFI_REGISTER)
+    {
+      FFI_INIT_TRAMPOLINE_WIN32 (&closure->tramp[0],
+                                   &ffi_closure_REGISTER,
+                                   (void*)codeloc);
+    }
+  else if (cif->abi == FFI_FASTCALL)
+    {
+      FFI_INIT_TRAMPOLINE_WIN32 (&closure->tramp[0],
+                                   &ffi_closure_FASTCALL,
+                                   (void*)codeloc);
+    }
+  else if (cif->abi == FFI_THISCALL)
+    {
+      FFI_INIT_TRAMPOLINE_WIN32 (&closure->tramp[0],
+                                   &ffi_closure_THISCALL,
+                                   (void*)codeloc);
+    }
+  else if (cif->abi == FFI_STDCALL || cif->abi == FFI_PASCAL)
+    {
+      FFI_INIT_TRAMPOLINE_WIN32 (&closure->tramp[0],
+                                   &ffi_closure_STDCALL,
+                                   (void*)codeloc);
+    }
+#ifdef X86_WIN32
+  else if (cif->abi == FFI_MS_CDECL)
+    {
+      FFI_INIT_TRAMPOLINE (&closure->tramp[0],
+                           &ffi_closure_SYSV,
+                           (void*)codeloc);
+    }
+#endif /* X86_WIN32 */
+#endif /* !X86_WIN64 */
+  else
+    {
+      return FFI_BAD_ABI;
+    }
+    
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+
+/* ------- Native raw API support -------------------------------- */
+
+#if !FFI_NO_RAW_API
+
+ffi_status
+ffi_prep_raw_closure_loc (ffi_raw_closure* closure,
+                          ffi_cif* cif,
+                          void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
+                          void *user_data,
+                          void *codeloc)
+{
+  int i;
+
+  if (cif->abi != FFI_SYSV
+#ifdef X86_WIN32
+      && cif->abi != FFI_THISCALL
+#endif
+     )
+    return FFI_BAD_ABI;
+
+  /* we currently don't support certain kinds of arguments for raw
+     closures.  This should be implemented by a separate assembly
+     language routine, since it would require argument processing,
+     something we don't do now for performance.  */
+
+  for (i = cif->nargs-1; i >= 0; i--)
+    {
+      FFI_ASSERT (cif->arg_types[i]->type != FFI_TYPE_STRUCT);
+      FFI_ASSERT (cif->arg_types[i]->type != FFI_TYPE_LONGDOUBLE);
+    }
+  
+#ifdef X86_WIN32
+  if (cif->abi == FFI_SYSV)
+    {
+#endif
+  FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_raw_SYSV,
+                       codeloc);
+#ifdef X86_WIN32
+    }
+  else if (cif->abi == FFI_THISCALL)
+    {
+      FFI_INIT_TRAMPOLINE_RAW_THISCALL (&closure->tramp[0], &ffi_closure_raw_THISCALL, codeloc, cif->bytes);
+    }
+#endif
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+
+static unsigned int 
+ffi_prep_args_raw(char *stack, extended_cif *ecif)
+{
+  const ffi_cif *cif = ecif->cif;
+  unsigned int i, passed_regs = 0;
+  
+#ifndef X86_WIN64
+  const unsigned int abi = cif->abi;
+  const unsigned int max_regs = (abi == FFI_THISCALL) ? 1
+                              : (abi == FFI_FASTCALL) ? 2
+                              : (abi == FFI_REGISTER) ? 3
+                              : 0;
+
+  if (cif->flags == FFI_TYPE_STRUCT)
+    ++passed_regs;
+  
+  for (i = 0; i < cif->nargs && passed_regs <= max_regs; i++)
+    {
+      if (cif->arg_types[i]->type == FFI_TYPE_FLOAT
+         || cif->arg_types[i]->type == FFI_TYPE_STRUCT)
+        continue;
+
+      size_t sz = cif->arg_types[i]->size;
+      if (sz == 0 || sz > FFI_SIZEOF_ARG)
+        continue;
+
+      ++passed_regs;
+    }
+#endif
+
+  memcpy (stack, ecif->avalue, cif->bytes);
+  return passed_regs;
+}
+
+/* we borrow this routine from libffi (it must be changed, though, to
+ * actually call the function passed in the first argument.  as of
+ * libffi-1.20, this is not the case.)
+ */
+
+void
+ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)
+{
+  extended_cif ecif;
+  void **avalue = (void **)fake_avalue;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  
+  /* If the return value is a struct and we don't have a return */
+  /* value address then we need to make one                     */
+
+  if (rvalue == NULL
+      && (cif->flags == FFI_TYPE_STRUCT
+          || cif->flags == FFI_TYPE_MS_STRUCT))
+    {
+      ecif.rvalue = alloca(cif->rtype->size);
+    }
+  else
+    ecif.rvalue = rvalue;
+    
+  
+  switch (cif->abi) 
+    {
+#ifndef X86_WIN32
+    case FFI_SYSV:
+      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,
+                    ecif.rvalue, fn);
+      break;
+#else
+    case FFI_SYSV:
+    case FFI_MS_CDECL:
+#endif
+#ifndef X86_WIN64
+    case FFI_STDCALL:
+    case FFI_THISCALL:
+    case FFI_FASTCALL:
+    case FFI_PASCAL:
+    case FFI_REGISTER:
+      ffi_call_win32(ffi_prep_args_raw, &ecif, cif->abi, cif->bytes, cif->flags,
+                     ecif.rvalue, fn);
+      break;
+#endif
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#endif
+
+#endif /* !__x86_64__  || X86_WIN64 */
+
diff --git a/src/x86/win32_msvc.S b/src/x86/win32_msvc.S
new file mode 100644
index 0000000..4d20de4
--- /dev/null
+++ b/src/x86/win32_msvc.S
@@ -0,0 +1,519 @@
+/* -----------------------------------------------------------------------
+   win32.S - Copyright (c) 2014  Anthony Green
+             Copyright (c) 1996, 1998, 2001, 2002, 2009  Red Hat, Inc.
+             Copyright (c) 2001  John Beniton
+             Copyright (c) 2002  Ranjit Mathew
+             Copyright (c) 2009  Daniel Witte
+
+
+   X86 Foreign Function Interface
+ 
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+ 
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+ 
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   -----------------------------------------------------------------------
+   */
+ 
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define CIF_BYTES_OFFSET 16
+#define CIF_FLAGS_OFFSET 20
+
+#ifndef _MSC_VER
+#error "Invalid configuration, this file needs to be built with msvc"
+#endif
+
+#define CLOSURE_CIF_OFFSET ((FFI_TRAMPOLINE_SIZE + 3) AND NOT 3)
+
+.386
+.MODEL FLAT, C
+
+EXTRN ffi_closure_SYSV_inner:NEAR
+EXTRN ffi_closure_WIN32_inner:NEAR
+
+_TEXT SEGMENT
+
+ffi_call_win32 PROC NEAR,
+    ffi_prep_args : NEAR PTR DWORD,
+    ecif          : NEAR PTR DWORD,
+    cif_abi       : DWORD,
+    cif_bytes     : DWORD,
+    cif_flags     : DWORD,
+    rvalue        : NEAR PTR DWORD,
+    fn            : NEAR PTR DWORD
+
+        ;; Make room for all of the new args.
+        mov  ecx, cif_bytes
+        sub  esp, ecx
+
+        mov  eax, esp
+
+        ;; Call ffi_prep_args
+        push ecif
+        push eax
+        call ffi_prep_args
+        add  esp, 8
+
+        ;; Prepare registers
+        ;; EAX stores the number of register arguments
+        cmp  eax, 0
+        je   fun
+        cmp  eax, 3
+        jl   prepr_two_cmp
+        
+        mov  ecx, esp
+        add  esp, 12
+        mov  eax, DWORD PTR [ecx+8]
+        jmp  prepr_two
+prepr_two_cmp:
+        cmp  eax, 2
+        jl   prepr_one_prep
+        mov  ecx, esp
+        add  esp, 8
+prepr_two:
+        mov  edx, DWORD PTR [ecx+4]
+        jmp  prepr_one
+prepr_one_prep:
+        mov  ecx, esp
+        add  esp, 4
+prepr_one:
+        mov  ecx, DWORD PTR [ecx]
+        cmp  cif_abi, 7 ;; FFI_REGISTER
+        jne  fun
+
+        xchg ecx, eax
+
+fun:
+        ;; Call function
+        call fn
+
+        ;; Load ecx with the return type code
+        mov  ecx, cif_flags
+
+        ;; If the return value pointer is NULL, assume no return value.
+        cmp  rvalue, 0
+        jne  ca_jumptable
+
+        ;; Even if there is no space for the return value, we are
+        ;; obliged to handle floating-point values.
+        cmp  ecx, FFI_TYPE_FLOAT
+        jne  ca_epilogue
+        fstp st(0)
+
+        jmp  ca_epilogue
+
+ca_jumptable:
+        jmp  [ca_jumpdata + 4 * ecx]
+ca_jumpdata:
+        ;; Do not insert anything here between label and jump table.
+        dd offset ca_epilogue       ;; FFI_TYPE_VOID
+        dd offset ca_retint         ;; FFI_TYPE_INT
+        dd offset ca_retfloat       ;; FFI_TYPE_FLOAT
+        dd offset ca_retdouble      ;; FFI_TYPE_DOUBLE
+        dd offset ca_retlongdouble  ;; FFI_TYPE_LONGDOUBLE
+        dd offset ca_retuint8       ;; FFI_TYPE_UINT8
+        dd offset ca_retsint8       ;; FFI_TYPE_SINT8
+        dd offset ca_retuint16      ;; FFI_TYPE_UINT16
+        dd offset ca_retsint16      ;; FFI_TYPE_SINT16
+        dd offset ca_retint         ;; FFI_TYPE_UINT32
+        dd offset ca_retint         ;; FFI_TYPE_SINT32
+        dd offset ca_retint64       ;; FFI_TYPE_UINT64
+        dd offset ca_retint64       ;; FFI_TYPE_SINT64
+        dd offset ca_epilogue       ;; FFI_TYPE_STRUCT
+        dd offset ca_retint         ;; FFI_TYPE_POINTER
+        dd offset ca_retstruct1b    ;; FFI_TYPE_SMALL_STRUCT_1B
+        dd offset ca_retstruct2b    ;; FFI_TYPE_SMALL_STRUCT_2B
+        dd offset ca_retint         ;; FFI_TYPE_SMALL_STRUCT_4B
+        dd offset ca_epilogue       ;; FFI_TYPE_MS_STRUCT
+
+        /* Sign/zero extend as appropriate.  */
+ca_retuint8:
+        movzx eax, al
+        jmp   ca_retint
+
+ca_retsint8:
+        movsx eax, al
+        jmp   ca_retint
+
+ca_retuint16:
+        movzx eax, ax
+        jmp   ca_retint
+
+ca_retsint16:
+        movsx eax, ax
+        jmp   ca_retint
+
+ca_retint:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        mov   [ecx + 0], eax
+        jmp   ca_epilogue
+
+ca_retint64:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        mov   [ecx + 0], eax
+        mov   [ecx + 4], edx
+        jmp   ca_epilogue
+
+ca_retfloat:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        fstp  DWORD PTR [ecx]
+        jmp   ca_epilogue
+
+ca_retdouble:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        fstp  QWORD PTR [ecx]
+        jmp   ca_epilogue
+
+ca_retlongdouble:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        fstp  TBYTE PTR [ecx]
+        jmp   ca_epilogue
+
+ca_retstruct1b:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        mov   [ecx + 0], al
+        jmp   ca_epilogue
+
+ca_retstruct2b:
+        ;; Load %ecx with the pointer to storage for the return value
+        mov   ecx, rvalue
+        mov   [ecx + 0], ax
+        jmp   ca_epilogue
+
+ca_epilogue:
+        ;; Epilogue code is autogenerated.
+        ret
+ffi_call_win32 ENDP
+
+ffi_closure_THISCALL PROC NEAR
+        ;; Insert the register argument on the stack as the first argument
+        xchg	DWORD PTR [esp+4], ecx
+        xchg	DWORD PTR [esp], ecx
+        push	ecx
+        jmp	ffi_closure_STDCALL
+ffi_closure_THISCALL ENDP
+
+ffi_closure_FASTCALL PROC NEAR
+        ;; Insert the 2 register arguments on the stack as the first argument
+        xchg	DWORD PTR [esp+4], edx
+        xchg	DWORD PTR [esp], ecx
+        push	edx
+        push	ecx
+        jmp	ffi_closure_STDCALL
+ffi_closure_FASTCALL ENDP
+
+ffi_closure_REGISTER PROC NEAR
+        ;; Insert the 3 register arguments on the stack as the first argument
+        push	eax
+        xchg	DWORD PTR [esp+8], ecx
+        xchg	DWORD PTR [esp+4], edx
+        push	ecx
+        push	edx
+        jmp	ffi_closure_STDCALL
+ffi_closure_REGISTER ENDP
+
+ffi_closure_SYSV PROC NEAR FORCEFRAME
+    ;; the ffi_closure ctx is passed in eax by the trampoline.
+
+        sub  esp, 40
+        lea  edx, [ebp - 24]
+        mov  [ebp - 12], edx         ;; resp
+        lea  edx, [ebp + 8]
+stub::
+        mov  [esp + 8], edx          ;; args
+        lea  edx, [ebp - 12]
+        mov  [esp + 4], edx          ;; &resp
+        mov  [esp], eax              ;; closure
+        call ffi_closure_SYSV_inner
+        mov  ecx, [ebp - 12]
+
+cs_jumptable:
+        jmp  [cs_jumpdata + 4 * eax]
+cs_jumpdata:
+        ;; Do not insert anything here between the label and jump table.
+        dd offset cs_epilogue       ;; FFI_TYPE_VOID
+        dd offset cs_retint         ;; FFI_TYPE_INT
+        dd offset cs_retfloat       ;; FFI_TYPE_FLOAT
+        dd offset cs_retdouble      ;; FFI_TYPE_DOUBLE
+        dd offset cs_retlongdouble  ;; FFI_TYPE_LONGDOUBLE
+        dd offset cs_retuint8       ;; FFI_TYPE_UINT8
+        dd offset cs_retsint8       ;; FFI_TYPE_SINT8
+        dd offset cs_retuint16      ;; FFI_TYPE_UINT16
+        dd offset cs_retsint16      ;; FFI_TYPE_SINT16
+        dd offset cs_retint         ;; FFI_TYPE_UINT32
+        dd offset cs_retint         ;; FFI_TYPE_SINT32
+        dd offset cs_retint64       ;; FFI_TYPE_UINT64
+        dd offset cs_retint64       ;; FFI_TYPE_SINT64
+        dd offset cs_retstruct      ;; FFI_TYPE_STRUCT
+        dd offset cs_retint         ;; FFI_TYPE_POINTER
+        dd offset cs_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B
+        dd offset cs_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B
+        dd offset cs_retint         ;; FFI_TYPE_SMALL_STRUCT_4B
+        dd offset cs_retmsstruct    ;; FFI_TYPE_MS_STRUCT
+
+cs_retuint8:
+        movzx eax, BYTE PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retsint8:
+        movsx eax, BYTE PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retuint16:
+        movzx eax, WORD PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retsint16:
+        movsx eax, WORD PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retint:
+        mov   eax, [ecx]
+        jmp   cs_epilogue
+
+cs_retint64:
+        mov   eax, [ecx + 0]
+        mov   edx, [ecx + 4]
+        jmp   cs_epilogue
+
+cs_retfloat:
+        fld   DWORD PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retdouble:
+        fld   QWORD PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retlongdouble:
+        fld   TBYTE PTR [ecx]
+        jmp   cs_epilogue
+
+cs_retstruct:
+        ;; Caller expects us to pop struct return value pointer hidden arg.
+        ;; Epilogue code is autogenerated.
+        ret	4
+
+cs_retmsstruct:
+        ;; Caller expects us to return a pointer to the real return value.
+        mov   eax, ecx
+        ;; Caller doesn't expects us to pop struct return value pointer hidden arg.
+        jmp   cs_epilogue
+
+cs_epilogue:
+        ;; Epilogue code is autogenerated.
+        ret
+ffi_closure_SYSV ENDP
+
+#if !FFI_NO_RAW_API
+
+#define RAW_CLOSURE_CIF_OFFSET ((FFI_TRAMPOLINE_SIZE + 3) AND NOT 3)
+#define RAW_CLOSURE_FUN_OFFSET (RAW_CLOSURE_CIF_OFFSET + 4)
+#define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)
+
+ffi_closure_raw_THISCALL PROC NEAR USES esi FORCEFRAME
+        sub esp, 36
+        mov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif
+        mov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data
+        mov [esp + 12], edx
+        lea edx, [ebp + 12]
+        jmp stubraw
+ffi_closure_raw_THISCALL ENDP
+
+ffi_closure_raw_SYSV PROC NEAR USES esi FORCEFRAME
+    ;; the ffi_closure ctx is passed in eax by the trampoline.
+
+        sub  esp, 40
+        mov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif
+        mov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data
+        mov  [esp + 12], edx                            ;; user_data
+        lea  edx, [ebp + 8]
+stubraw::
+        mov  [esp + 8], edx                             ;; raw_args
+        lea  edx, [ebp - 24]
+        mov  [esp + 4], edx                             ;; &res
+        mov  [esp], esi                                 ;; cif
+        call DWORD PTR [eax + RAW_CLOSURE_FUN_OFFSET]   ;; closure->fun
+        mov  eax, [esi + CIF_FLAGS_OFFSET]              ;; cif->flags
+        lea  ecx, [ebp - 24]
+
+cr_jumptable:
+        jmp  [cr_jumpdata + 4 * eax]
+cr_jumpdata:
+        ;; Do not insert anything here between the label and jump table.
+        dd offset cr_epilogue       ;; FFI_TYPE_VOID
+        dd offset cr_retint         ;; FFI_TYPE_INT
+        dd offset cr_retfloat       ;; FFI_TYPE_FLOAT
+        dd offset cr_retdouble      ;; FFI_TYPE_DOUBLE
+        dd offset cr_retlongdouble  ;; FFI_TYPE_LONGDOUBLE
+        dd offset cr_retuint8       ;; FFI_TYPE_UINT8
+        dd offset cr_retsint8       ;; FFI_TYPE_SINT8
+        dd offset cr_retuint16      ;; FFI_TYPE_UINT16
+        dd offset cr_retsint16      ;; FFI_TYPE_SINT16
+        dd offset cr_retint         ;; FFI_TYPE_UINT32
+        dd offset cr_retint         ;; FFI_TYPE_SINT32
+        dd offset cr_retint64       ;; FFI_TYPE_UINT64
+        dd offset cr_retint64       ;; FFI_TYPE_SINT64
+        dd offset cr_epilogue       ;; FFI_TYPE_STRUCT
+        dd offset cr_retint         ;; FFI_TYPE_POINTER
+        dd offset cr_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B
+        dd offset cr_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B
+        dd offset cr_retint         ;; FFI_TYPE_SMALL_STRUCT_4B
+        dd offset cr_epilogue       ;; FFI_TYPE_MS_STRUCT
+
+cr_retuint8:
+        movzx eax, BYTE PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retsint8:
+        movsx eax, BYTE PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retuint16:
+        movzx eax, WORD PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retsint16:
+        movsx eax, WORD PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retint:
+        mov   eax, [ecx]
+        jmp   cr_epilogue
+
+cr_retint64:
+        mov   eax, [ecx + 0]
+        mov   edx, [ecx + 4]
+        jmp   cr_epilogue
+
+cr_retfloat:
+        fld   DWORD PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retdouble:
+        fld   QWORD PTR [ecx]
+        jmp   cr_epilogue
+
+cr_retlongdouble:
+        fld   TBYTE PTR [ecx]
+        jmp   cr_epilogue
+
+cr_epilogue:
+        ;; Epilogue code is autogenerated.
+        ret
+ffi_closure_raw_SYSV ENDP
+
+#endif /* !FFI_NO_RAW_API */
+
+ffi_closure_STDCALL PROC NEAR FORCEFRAME
+        mov  eax, [esp] ;; the ffi_closure ctx passed by the trampoline.
+
+        sub  esp, 40
+        lea  edx, [ebp - 24]
+        mov  [ebp - 12], edx         ;; resp
+        lea  edx, [ebp + 12]         ;; account for stub return address on stack
+        mov  [esp + 8], edx          ;; args
+        lea  edx, [ebp - 12]
+        mov  [esp + 4], edx          ;; &resp
+        mov  [esp], eax              ;; closure
+        call ffi_closure_WIN32_inner
+        mov  ecx, [ebp - 12]
+
+        xchg [ebp + 4], eax          ;;xchg size of stack parameters and ffi_closure ctx
+        mov  eax, DWORD PTR [eax + CLOSURE_CIF_OFFSET]
+        mov  eax, DWORD PTR [eax + CIF_FLAGS_OFFSET]
+
+cd_jumptable:
+        jmp  [cd_jumpdata + 4 * eax]
+cd_jumpdata:
+        ;; Do not insert anything here between the label and jump table.
+        dd offset cd_epilogue       ;; FFI_TYPE_VOID
+        dd offset cd_retint         ;; FFI_TYPE_INT
+        dd offset cd_retfloat       ;; FFI_TYPE_FLOAT
+        dd offset cd_retdouble      ;; FFI_TYPE_DOUBLE
+        dd offset cd_retlongdouble  ;; FFI_TYPE_LONGDOUBLE
+        dd offset cd_retuint8       ;; FFI_TYPE_UINT8
+        dd offset cd_retsint8       ;; FFI_TYPE_SINT8
+        dd offset cd_retuint16      ;; FFI_TYPE_UINT16
+        dd offset cd_retsint16      ;; FFI_TYPE_SINT16
+        dd offset cd_retint         ;; FFI_TYPE_UINT32
+        dd offset cd_retint         ;; FFI_TYPE_SINT32
+        dd offset cd_retint64       ;; FFI_TYPE_UINT64
+        dd offset cd_retint64       ;; FFI_TYPE_SINT64
+        dd offset cd_epilogue       ;; FFI_TYPE_STRUCT
+        dd offset cd_retint         ;; FFI_TYPE_POINTER
+        dd offset cd_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B
+        dd offset cd_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B
+        dd offset cd_retint         ;; FFI_TYPE_SMALL_STRUCT_4B
+
+cd_retuint8:
+        movzx eax, BYTE PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retsint8:
+        movsx eax, BYTE PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retuint16:
+        movzx eax, WORD PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retsint16:
+        movsx eax, WORD PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retint:
+        mov   eax, [ecx]
+        jmp   cd_epilogue
+
+cd_retint64:
+        mov   eax, [ecx + 0]
+        mov   edx, [ecx + 4]
+        jmp   cd_epilogue
+
+cd_retfloat:
+        fld   DWORD PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retdouble:
+        fld   QWORD PTR [ecx]
+        jmp   cd_epilogue
+
+cd_retlongdouble:
+        fld   TBYTE PTR [ecx]
+        jmp   cd_epilogue
+
+cd_epilogue:
+        mov   esp, ebp
+        pop   ebp
+        mov   ecx, [esp + 4]  ;; Return address
+        add   esp, [esp]      ;; Parameters stack size
+        add   esp, 8
+        jmp   ecx
+ffi_closure_STDCALL ENDP
+
+_TEXT ENDS
+END
-- 
2.12.2.windows.2


From a8d87e3694f65c03afc80048f8a76ea9405553a9 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Tue, 28 Feb 2017 03:09:47 +0530
Subject: [PATCH 04/11] meson: Use add_project_arguments for global args

Allows use as a subproject
---
 meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index f137bc4..5eaae56 100644
--- a/meson.build
+++ b/meson.build
@@ -6,7 +6,7 @@ project('libffi', 'c', version : '3.2.1',
 cc = meson.get_compiler('c')
 
 # For FFI_EXTERN symbol exporting
-add_global_arguments('-DFFI_BUILDING', language : 'c')
+add_project_arguments('-DFFI_BUILDING', language : 'c')
 
 ffi_conf = configuration_data()
 
-- 
2.12.2.windows.2


From 8394da157611b992fe6f666b324fb56b92deed27 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Tue, 28 Feb 2017 03:18:59 +0530
Subject: [PATCH 05/11] meson: Declare a dependency for ffi_lib

Allows usage of the library via subprojects
---
 src/meson.build | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/meson.build b/src/meson.build
index b747948..bebd3e6 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -87,3 +87,6 @@ ffi_lib = library('ffi', ffi_c_sources, ffi_asm_sources,
   # current - age
   soversion : '7',
   install : true)
+
+ffi_dep = declare_dependency(link_with : ffi_lib,
+  include_directories : ffiinc)
-- 
2.12.2.windows.2


From 28c32ffe5944ec06778c93ab815e82b198a67a50 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Wed, 1 Mar 2017 12:45:54 +0530
Subject: [PATCH 06/11] meson: Fix include paths when used as a subproject

We can't just blindly assume that everything will be relative to the
build root. Must use paths relative to the current source/build dir.
---
 src/meson.build | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/meson.build b/src/meson.build
index bebd3e6..9a9feba 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -61,15 +61,18 @@ if cc.get_id() == 'msvc'
   ml = find_program('ml', 'ml64')
   ffi_asm_objs = []
   foreach asm_source : ffi_asm_sources
+    incflags = ['/I' + join_paths(meson.current_source_dir(), '..'),
+                '/I' + join_paths(meson.current_build_dir(), '..'),
+                '/I' + join_paths(meson.current_source_dir(), '..', 'include'),
+                '/I' + join_paths(meson.current_build_dir(), '..', 'include')]
     preproc_name = asm_source.underscorify() + '.i'
     obj_name = asm_source.underscorify() + '.obj'
     preproc = custom_target(preproc_name,
         input : asm_source,
         output : preproc_name,
         command : [cl, '/nologo', '/EP', '/P', '/Fi@OUTPUT@',
-                   '/I.', '/I..', '/Iinclude', '/I..\\include',
                    '/DTARGET=' + TARGET, '/DFFI_BUILDING',
-                   '@INPUT@'])
+                   '@INPUT@'] + incflags)
     ffi_asm_objs += custom_target(obj_name,
         input : preproc,
         output : obj_name,
-- 
2.12.2.windows.2


From ef501d66033d3d7e83cbb6e0f7c4c90a0d9b69b8 Mon Sep 17 00:00:00 2001
From: Ignacio Casal Quinteiro <qignacio@amazon.com>
Date: Sat, 30 Dec 2017 06:57:44 +0530
Subject: [PATCH 07/11] Use C89 declarations for x86 MSVC code

Fixes building with VS2013 which only supports C89.

See: https://github.com/wingtk/gvsbuild/issues/206
---
 src/x86/ffiold-msvc.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/x86/ffiold-msvc.c b/src/x86/ffiold-msvc.c
index 006c95d..939642f 100644
--- a/src/x86/ffiold-msvc.c
+++ b/src/x86/ffiold-msvc.c
@@ -99,11 +99,13 @@ unsigned int ffi_prep_args(char *stack, extended_cif *ecif)
        i != 0;
        i--, p_arg += dir, p_argv += dir)
     {
+      size_t z;
+
       /* Align if necessary */
       if ((sizeof(void*) - 1) & (size_t) argp)
         argp = (char *) ALIGN(argp, sizeof(void*));
 
-      size_t z = (*p_arg)->size;
+      z = (*p_arg)->size;
 
 #ifdef X86_WIN64
       if (z > FFI_SIZEOF_ARG
@@ -599,11 +601,13 @@ ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,
        i != 0;
        i--, p_arg += dir, p_argv += dir)
     {
+      size_t z;
+
       /* Align if necessary */
       if ((sizeof(void*) - 1) & (size_t) argp)
         argp = (char *) ALIGN(argp, sizeof(void*));
 
-      size_t z = (*p_arg)->size;
+      z = (*p_arg)->size;
 
 #ifdef X86_WIN64
       if (z > FFI_SIZEOF_ARG
-- 
2.12.2.windows.2


From 86cdeb020ef91331ecd22a03f5f9fe325945a721 Mon Sep 17 00:00:00 2001
From: Mathieu Duponchelle <mathieu@centricular.com>
Date: Thu, 15 Mar 2018 19:08:30 +0100
Subject: [PATCH 08/11] ffiold_msvc.c: ALIGN was renamed to FFI_ALIGN

---
 src/x86/ffiold-msvc.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/x86/ffiold-msvc.c b/src/x86/ffiold-msvc.c
index 939642f..fa8ef5d 100644
--- a/src/x86/ffiold-msvc.c
+++ b/src/x86/ffiold-msvc.c
@@ -103,7 +103,7 @@ unsigned int ffi_prep_args(char *stack, extended_cif *ecif)
 
       /* Align if necessary */
       if ((sizeof(void*) - 1) & (size_t) argp)
-        argp = (char *) ALIGN(argp, sizeof(void*));
+        argp = (char *) FFI_ALIGN(argp, sizeof(void*));
 
       z = (*p_arg)->size;
 
@@ -299,7 +299,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
 #endif
             cif->flags = FFI_TYPE_STRUCT;
           /* allocate space for return value pointer */
-          cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
+          cif->bytes += FFI_ALIGN(sizeof(void*), FFI_SIZEOF_ARG);
         }
       break;
 
@@ -318,8 +318,8 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
   for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
     {
       if (((*ptr)->alignment - 1) & cif->bytes)
-        cif->bytes = ALIGN(cif->bytes, (*ptr)->alignment);
-      cif->bytes += (unsigned)ALIGN((*ptr)->size, FFI_SIZEOF_ARG);
+        cif->bytes = FFI_ALIGN(cif->bytes, (*ptr)->alignment);
+      cif->bytes += (unsigned)FFI_ALIGN((*ptr)->size, FFI_SIZEOF_ARG);
     }
 
 #ifdef X86_WIN64
@@ -605,7 +605,7 @@ ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,
 
       /* Align if necessary */
       if ((sizeof(void*) - 1) & (size_t) argp)
-        argp = (char *) ALIGN(argp, sizeof(void*));
+        argp = (char *) FFI_ALIGN(argp, sizeof(void*));
 
       z = (*p_arg)->size;
 
-- 
2.12.2.windows.2


From 53291b332b1bc061a3409d3b60c38f313609b98e Mon Sep 17 00:00:00 2001
From: Matthew Waters <matthew@centricular.com>
Date: Fri, 16 Mar 2018 15:10:04 +1100
Subject: [PATCH 09/11] x86/win64: disable runtime stack frame checks with msvc
 around built assembly

MSVC can add truntime code that checks if a stack frame is mismanaged
however our custom assembly delibrately accesses and modifies the parent
stack frame.  Fortunately we can disable that specific check for the
function call so do that.
---
 src/x86/ffiw64.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/x86/ffiw64.c b/src/x86/ffiw64.c
index f787525..88bb3a3 100644
--- a/src/x86/ffiw64.c
+++ b/src/x86/ffiw64.c
@@ -106,6 +106,14 @@ EFI64(ffi_prep_cif_machdep)(ffi_cif *cif)
   return FFI_OK;
 }
 
+/* we perform some black magic here to use some of the parent's
+ * stack frame in ff_call_win64() that breaks with the msvc compiler
+ * with the /RTCs or /GZ flags.  Disable the 'Stack frame run time
+ * error checking' for this function so we don't hit weird exceptions
+ * in debug builds */
+#if defined(_MSVC_VER)
+#pragma runtime_checks("s", off)
+#endif
 static void
 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 	      void **avalue, void *closure)
@@ -170,6 +178,9 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 
   ffi_call_win64 (stack, frame, closure);
 }
+#if defined(_MSVC_VER)
+#pragma runtime_checks("s", restore)
+#endif
 
 void
 EFI64(ffi_call)(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
-- 
2.12.2.windows.2


From f8aff9ca61424f3b1ad6efef927eef49323e6306 Mon Sep 17 00:00:00 2001
From: Matthew Waters <matthew@centricular.com>
Date: Fri, 16 Mar 2018 22:33:35 +1100
Subject: [PATCH 10/11] win64: fix msvc specific compiler check

It's _MSC_VER not _MSVC_VER
---
 src/x86/ffiw64.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/x86/ffiw64.c b/src/x86/ffiw64.c
index 88bb3a3..c91c72a 100644
--- a/src/x86/ffiw64.c
+++ b/src/x86/ffiw64.c
@@ -111,7 +111,7 @@ EFI64(ffi_prep_cif_machdep)(ffi_cif *cif)
  * with the /RTCs or /GZ flags.  Disable the 'Stack frame run time
  * error checking' for this function so we don't hit weird exceptions
  * in debug builds */
-#if defined(_MSVC_VER)
+#if defined(_MSC_VER)
 #pragma runtime_checks("s", off)
 #endif
 static void
@@ -178,7 +178,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 
   ffi_call_win64 (stack, frame, closure);
 }
-#if defined(_MSVC_VER)
+#if defined(_MSC_VER)
 #pragma runtime_checks("s", restore)
 #endif
 
-- 
2.12.2.windows.2


From 464b3a6dd294910fec84f3d139431926e1d0927f Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Tue, 28 Aug 2018 12:27:02 +0530
Subject: [PATCH 11/11] meson: Rename 'debug' to 'ffi-debug'

'debug' is a reserved keyword and starting with meson 0.48 using it as
a user option causes an error:

> meson_options.txt:2: Option name debug is reserved.
---
 meson.build       | 2 +-
 meson_options.txt | 2 +-
 src/meson.build   | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/meson.build b/meson.build
index 5eaae56..b31cb64 100644
--- a/meson.build
+++ b/meson.build
@@ -171,7 +171,7 @@ if host_system != 'windows'
 endif
 
 # User options
-if get_option('debug')
+if get_option('ffi-debug')
   ffi_conf.set('FFI_DEBUG')
 endif
 if not get_option('raw_api')
diff --git a/meson_options.txt b/meson_options.txt
index 7e5bede..2c7f517 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -1,5 +1,5 @@
 # Toggle this if you want extra debugging
-option('debug', type : 'boolean', value : false)
+option('ffi-debug', type : 'boolean', value : false)
 # Toggle this if you do not want support for aggregate types
 option('structs', type : 'boolean', value : true)
 # Toggle this if you do not want support for the raw API
diff --git a/src/meson.build b/src/meson.build
index 9a9feba..ed5c184 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -8,7 +8,7 @@ ffi_c_sources = [
 
 ffi_asm_sources = []
 
-if get_option('debug')
+if get_option('ffi-debug')
   ffi_c_sources += ['debug.c']
 endif
 
-- 
2.12.2.windows.2

